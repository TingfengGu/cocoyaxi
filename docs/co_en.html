<!DOCTYPE html>
<html>
<head>
<title>co_1.1_en.html</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
@import 'https://fonts.googleapis.com/css?family=Palatino';
@import 'https://fonts.googleapis.com/css?family=Palatino+Linotype';
@import 'https://fonts.googleapis.com/css?family=Georgia';
@import 'https://fonts.googleapis.com/css?family=Source+Code+Pro';

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  box-sizing: border-box;
  width: 100vw;
}

*, *:before, *:after {
  box-sizing: inherit;
}

body {
  width: 1080px;
  margin: 0 auto;
  padding: 30px 0;
  overflow-x: hidden;
  font-family: Palatino,"Palatino Linotype",Georgia,SimSun,serif,'Microsoft YaHei';
  font-size: 18px;
}

button, input, select, textarea, label {
  margin: 0;
  padding: 0;
  font-family: inherit;
  font-size: inherit;
}

body {
  line-height: 1.75;
  color: #333;
}

h1, h2, h3, h4, h5, h6 {
  padding: 0;
  margin: 60px 0 30px;
  line-height: 1.25;
}

h1 {
  font-size: 32px;
  font-weight: 800;
  border-bottom: none;
  text-align: center;
}

h2 {
  font-size: 24px;
  font-weight: 600;
  text-align: left;
}

h3, h4, h5, h6 {
  margin: 40px 0 30px;
  font-size: 20px;
  font-weight: 600;
  text-align: left;
}

p {
  text-align: justify;
  line-height: 1.75;
}

pre:not(.hljs),
pre.hljs code {
  display: block;
  padding: 0px;
  overflow-x: auto;
  line-height: 1.75;
  color: #333;
  background: #f8f8f8;
  font-weight: normal;
  font-family: "Source Code Pro",Consolas,monospace,Courier,'华文楷体',SimKai,'Microsoft YaHei',KaiTi,'楷体',SimSun;
  font-size: 14px;
}

code {
  padding: 0px 3px;
  hyphens: none;
  color: #e11;
  background: #f9f9f9;
  font-weight: bold;
  font-family: Palatino,"Source Code Pro",Consolas,monospace,Courier,serif,SimSun,'华文楷体',SimKai,'Microsoft YaHei',KaiTi,'楷体';
}

blockquote {
  margin: 1em 0;
  padding: 0 2em;
  border-left: 3px solid #ddd;
}

ul, ol {
  padding: 0 0 0 20px;
}

li {
  margin: 4px 0;
  padding: 0;
}

ul li ul li {
  font-family: "Source Code Pro",Courier,Consolas,monospace,NSimSun,SimSun,'Songti SC',serif,'Microsoft YaHei';
}

a {
  color: #4169E1;
  font-weight: bold;
  margin: 0;
  padding: 0;
  vertical-align: baseline;
  text-decoration: none;
}

a:hover {
  text-decoration: none;
  color: #b8860b;
}

sup a {
  border-bottom: none;
}

nav li a {
  border-bottom: none;
}

nav li a:hover {
  border-bottom: 1px solid;
}

table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}

table thead th {
  border-bottom: 1px solid #666;
}

th, td {
  padding: 5px;
}

thead, tfoot, tr:nth-child(even) {
  background: #f8f8f8;
}
.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #f8f8f8;
  color: #333;
}

.hljs-comment,
.hljs-quote {
  color: #057400;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-section,
.hljs-name {
  color: #AA0D91;
}

.hljs-variable,
.hljs-template-variable {
  color: #660;
}

.hljs-string,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-regexp {
  color: #C41A16;
}

.hljs-literal,
.hljs-symbol,
.hljs-bullet,
.hljs-meta,
.hljs-number,
.hljs-link {
  color: #b8860b;
}

.hljs-title,
.hljs-doctag,
.hljs-type,
.hljs-attr,
.hljs-built_in,
.hljs-builtin-name,
.hljs-params {
  color: #008080;
}

.hljs-attribute,
.hljs-subst {
  color: #333;
}

.hljs-formula {
  background-color: #eee;
  font-style: italic;
}

.hljs-selector-id,
.hljs-selector-class {
  color: #9B703F
}

.hljs-addition {
  background-color: #baeeba;
}

.hljs-deletion {
  background-color: #ffc8bd;
}

.hljs-doctag,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}

/**
 * -------------------------------------------------------------------------
 *  Media Queries
 * -------------------------------------------------------------------------
 *
 * The @viewport tag does the same thing as
 *
 *   <meta name="viewport" content="width=device-width">
 *
 * but in the future W3C standard way. The -ms- prefix is required for
 * IE10+ to render responsive styling in Windows 8 "snapped" views;
 * IE10+ does not honour the meta tag.
 */

@-ms-viewport {
  width: device-width;
}

@viewport {
  width: device-width;
}

/* Tablet screens and smaller */

@media screen and (max-width: 960px) {

  body {
    width: auto;
    max-width: 700px;
  }
}

/* Landscape phone screens and smaller */

@media screen and (max-width: 720px) {
}

/* Portrait phone screens */

@media screen and (max-width: 480px) {

  body {
    font-size: 18px;
  }

  h1 {
    font-size: 28px;
  }

  h2 {
    font-size: 22px;
    font-weight: 600;
  }

  h3, h4, h5, h6 {
    font-size: 20px;
    font-weight: 600;
  }
}
</style>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="documents-for-co-v11">Documents for co v1.1</h1>
<font face="Arial" size=3>
<center>
Alvin &nbsp;2020/07/07
</center>
<center>
idealvin@qq.com
</center>
</font>
<p>Section 1-10 was translated by <a href="https://github.com/Leedehai">Leedehai</a>, 11-15 was translated by <a href="https://github.com/daidai21">daidai21</a>. Thanks here.</p>
<p><a href="https://github.com/idealvin/co/">CO</a> is an elegant and efficient C ++ basic library that supports Linux, Windows and Mac platforms. This document will introduce the components of CO and their usages.</p>
<h2 id="1-overview">1. Overview</h2>
<p><code>CO</code> pursues minimalism and efficiency. It does not rely on third-party libraries such as <a href="https://www.boost.org/">boost</a>, and uses only a few C++11 features.</p>
<ul>
<li>
<p>CO contains the following functional components:</p>
<ul>
<li>Basic definitions (def)</li>
<li>Atomic operations (atomic)</li>
<li>Fast random number generator (ramdom)</li>
<li>LruMap</li>
<li>Fast string casting for basic types (fast)</li>
<li>Efficient byte stream (fastream)</li>
<li>Efficient strings (fastring)</li>
<li>String operations (str)</li>
<li>Command line arguments and configuration file parsing library (flag)</li>
<li>Efficient streaming log library (log)</li>
<li>Unit testing framework (unitest)</li>
<li>Time library (time)</li>
<li>Thread library (thread)</li>
<li>Coroutine library (co)</li>
<li>Efficient json library</li>
<li>High-performance json rpc framework</li>
<li>Hash library</li>
<li>Path library</li>
<li>File system operations (fs)</li>
<li>System operations (os)</li>
</ul>
</li>
<li>
<p>C++11 features used by CO:</p>
<ul>
<li><code>auto</code></li>
<li><code>std::move</code></li>
<li><code>std::bind</code></li>
<li><code>std::function</code></li>
<li><code>std::unique_ptr</code></li>
<li><code>std::unordered_map</code></li>
<li><code>std::unordered_set</code></li>
<li>variadic templates</li>
</ul>
</li>
</ul>
<h2 id="2-basic-definitions-def">2. Basic definitions (def)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/def.h">co/def.h</a>.</p>
<h3 id="21-fixed-width-integers">2.1 Fixed-width integers</h3>
<pre class="hljs"><code><div> int8   int16   int32   int64
uint8  uint16  uint32  uint64
</div></code></pre>
<p>Their widths don't vary across platforms, so there should be no compatibility issues. <a href="https://google.github.io/styleguide/cppguide.html#Integer_Types">Google Code Style</a> suggests that one should not use built-in integer types like <code>short</code>, <code>long</code>, <code>long long</code>, except for <code>int</code>.</p>
<p><code>def.h</code> also provides the minimum and maximum values of the aforementioned integer types:</p>
<pre class="hljs"><code><div>MAX_UINT8  MAX_UINT16  MAX_UINT32  MAX_UINT64
MAX_INT8   MAX_INT16   MAX_INT32   MAX_INT64
MIN_INT8   MIN_INT16   MIN_INT32   MIN_INT64
</div></code></pre>
<h3 id="22-readwrite-1-2-4-8-bytes">2.2 Read/write 1, 2, 4, 8 bytes</h3>
<p><code>def.h</code> provides the below macros to facilitate reading/writing 1/2/4/8 bytes of data (note memory alignment is important):</p>
<pre class="hljs"><code><div>load8  load16  load32  load64
save8  save16  save32  save64
</div></code></pre>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div>uint64 v;                  <span class="hljs-comment">// 8 bytes</span>
save32(&amp;v, <span class="hljs-number">7</span>);             <span class="hljs-comment">// set the first 4 bytes to 7</span>
uint16 x = load16(&amp;v);     <span class="hljs-comment">// read the first 2 bytes of v</span>
</div></code></pre>
<h3 id="23-disallowcopyandassign">2.3 DISALLOW_COPY_AND_ASSIGN</h3>
<p>This macro deletes copy constructors and assignment operators in a C++ class.</p>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> {</span>
  <span class="hljs-keyword">public</span>:
    T();
    DISALLOW_COPY_AND_ASSIGN(T);
};
</div></code></pre>
<h3 id="24-forcecast-type-coercion">2.4 force_cast type coercion</h3>
<p><code>force_cast</code> is an encapsulation of C-style type casting</p>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> c = force_cast&lt;<span class="hljs-keyword">char</span>&gt;(<span class="hljs-number">97</span>); <span class="hljs-comment">// char c = (char) 97;</span>
</div></code></pre>
<h3 id="25-forceinline-and-thread">2.5 __forceinline and __thread</h3>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?view=vs-2019#inline-__inline-and-__forceinline">__forceinline</a> is a keyword in Visual Studio on Windows. On other platforms, it can be provided by the macro below:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __forceinline __attribute__((always_inline))</span>
</div></code></pre>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.4/gcc/Thread-Local.html">__thread</a> is a keyword in GCC to support <a href="https://wiki.osdev.org/Thread_Local_Storage">TLS</a>. On Windows, it can be provided by the macro below:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __thread __declspec(thread)</span>
</div></code></pre>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// get the ID of the current thread</span>
<span class="hljs-function">__forceinline <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gettid</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">static</span> __thread <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (id != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> id;
    <span class="hljs-keyword">return</span> id = __gettid();
}
</div></code></pre>
<h3 id="26-unlikely">2.6 unlikely</h3>
<p>The macro <code>unlikely</code> is used to aid branch predictions in GCC and Clang:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// it is logically equivalent to (v == -1), but provides a hint to the compiler </span>
<span class="hljs-comment">// that the probability of v == -1 is small</span>
<span class="hljs-keyword">if</span> (unlikey(v == <span class="hljs-number">-1</span>)) {
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"v == -1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h2 id="3-atomic-operations">3. Atomic operations</h2>
<p>include: <a href="https://github.com/idealvin/co/tree/master/include/co/atomic.h">co/atomic.h</a>.</p>
<p>Library <code>atomic</code> implements the following atomic operations:</p>
<pre class="hljs"><code><div>atomic_inc        atomic_dec        atomic_add        atomic_sub
atomic_fetch_inc  atomic_fetch_dec  atomic_fetch_add  atomic_fetch_sub

atomic_or         atomic_and        atomic_xor
atomic_fetch_or   atomic_fetch_and  atomic_fetch_xor

atomic_swap    atomic_compare_swap
atomic_get     atomic_set    atomic_reset
</div></code></pre>
<p>These operations is suitable for 1-, 2-, 4- and 8-byte data. The <code>fetch</code> versions of <code>inc</code>, <code>dec</code>, <code>add</code>, <code>sub</code>, <code>or</code>, <code>and</code>, <code>xor</code> are different from the vanilla versions, in that the former returns the value before the operations while the latter returns the value after the operations.</p>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> b = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
uint64 u = <span class="hljs-number">0</span>;
<span class="hljs-keyword">void</span>* p = <span class="hljs-number">0</span>;

atomic_inc(&amp;i);                 <span class="hljs-comment">// return ++i;</span>
atomic_dec(&amp;i);                 <span class="hljs-comment">// return --i;</span>
atomic_add(&amp;i, <span class="hljs-number">3</span>);              <span class="hljs-comment">// return i += 3;</span>
atomic_sub(&amp;i, <span class="hljs-number">3</span>);              <span class="hljs-comment">// return i -= 3;</span>
atomic_fetch_inc(&amp;u);           <span class="hljs-comment">// return u++;</span>

atomic_or(&amp;i, <span class="hljs-number">8</span>);               <span class="hljs-comment">// return i |= 8;</span>
atomic_and(&amp;i, <span class="hljs-number">7</span>);              <span class="hljs-comment">// return i &amp;= 7;</span>
atomic_xor(&amp;i, <span class="hljs-number">7</span>);              <span class="hljs-comment">// return i ^= 7;</span>
atomic_fetch_xor(&amp;i, <span class="hljs-number">7</span>);        <span class="hljs-comment">// v = i; i ^= 7; return v;</span>

atomic_swap(&amp;b, <span class="hljs-literal">true</span>);          <span class="hljs-comment">// v = b; b = true; return v;</span>
atomic_compare_swap(&amp;i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// v = i; if (i == 0) i = 1; return v;</span>

atomic_get(&amp;u);                 <span class="hljs-comment">// return u;</span>
atomic_set(&amp;u, <span class="hljs-number">7</span>);              <span class="hljs-comment">// u = 7;</span>
atomic_reset(&amp;i);               <span class="hljs-comment">// i = 0;</span>

<span class="hljs-comment">// atomic operations on pointers</span>
atomic_set(&amp;p, <span class="hljs-number">0</span>);
atomic_swap(&amp;p, <span class="hljs-number">8</span>);
atomic_compare_swap(&amp;p, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);
</div></code></pre>
<h2 id="4-random-number-generator-random">4. Random number generator (random)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/random.h">co/random.h</a>.</p>
<p><code>Random</code> is a speedy pseudo-random number generator, capable of generating random integers between 1 and 2G-2 without consecutive repetitions. Though <a href="https://github.com/google/leveldb/blob/master/util/random.h">leveldb</a> uses this algorithm, this library chose a different constant <code>16385</code>, which is faster.</p>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">Random <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span></span>;      <span class="hljs-comment">// 7 is the seed, which defaults to 1</span>
<span class="hljs-keyword">int</span> n = r.next(); <span class="hljs-comment">// !! not thread-safe</span>
</div></code></pre>
<h2 id="5-lrumap">5. LruMap</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/lru_map.h">co/lru_map.h</a>.</p>
<p>LRU is a popular caching strategy. When its size grows to the capacity, it will purge the least recently used data. <code>LruMap</code> is based on the implementation of <code>std::list</code> and <code>std::unordered_map</code>. Its elements are stored without order.</p>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">LruMap&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">128</span>)</span></span>;         <span class="hljs-comment">// capacity: 128</span>
m.insert(<span class="hljs-number">1</span>, <span class="hljs-number">23</span>);                 <span class="hljs-comment">// when m.size() &gt; 128, delete the last element</span>
                                 <span class="hljs-comment">// in the internal list (least recently used).</span>
                                 <span class="hljs-comment">// !! if key already exists, no inseration done</span>
<span class="hljs-keyword">auto</span> it = m.find(<span class="hljs-number">1</span>);             <span class="hljs-comment">// if found, put 1 at the beginning of the list</span>
<span class="hljs-keyword">if</span> (it != m.end()) m.erase(it);  <span class="hljs-comment">// erase by iterator</span>
m.erase(it-&gt;first);              <span class="hljs-comment">// erase by key</span>
</div></code></pre>
<h2 id="6-fast-string-casting-for-basic-types-fast">6. Fast string casting for basic types (fast)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fast.h">co/fast.h</a>.</p>
<p>Library <code>fast</code> provides functions below:</p>
<pre class="hljs"><code><div>u32toh  u64toh  u32toa  u64toa  i32toa  i64toa  dtoa
</div></code></pre>
<p><code>xtoh</code>-family converts an integer into a hexadecimal string. It caches the results corresponding to the first 256 numbers (2 bytes) in a table. Testing across platforms suggested it is 10-25 times faster than <code>snprintf</code>.</p>
<p><code>xtoa</code>-family converts an integer into an ASCII decimal string. It caches the results corresponding to the first 10000 numbers (4-bytes). Testing across platforms suggested it is 10-25 times faster than <code>snprintf</code>.</p>
<p><code>dtoa</code> uses the implementation by [Milo Yip] (https://github.com/miloyip), see [miloyip/dtoa-benchmark] (https://github.com/miloyip/dtoa-benchmark) for details. The early implementation based on <code>LruMap</code> was deprecated.</p>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];
<span class="hljs-keyword">int</span> len = fast::u32toh(<span class="hljs-number">255</span>, buf); <span class="hljs-comment">// "0xff", len is 4</span>
<span class="hljs-keyword">int</span> len = fast::i32toa(<span class="hljs-number">-99</span>, buf); <span class="hljs-comment">// "-99", len is 3</span>
<span class="hljs-keyword">int</span> len = fast::dtoa(<span class="hljs-number">0.123</span>, buf); <span class="hljs-comment">// "0.123", len is 5</span>
</div></code></pre>
<h2 id="7-efficient-byte-stream">7. Efficient byte stream</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fastream.h">co/fastream.h</a>.</p>
<p><code>std::ostringstream</code> in the C++ standard library is significantly less performant than <code>snprintf</code>. <code>fastream</code> inherits from the <code>fast::stream</code> class and supports streaming output and binary append operations. Among them, streaming output is about 10~30 times faster than snprintf on different platforms.</p>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">fastream <span class="hljs-title">fs</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;          <span class="hljs-comment">// preallocate 1K memory</span>
fs &lt;&lt; <span class="hljs-string">"hello world"</span> &lt;&lt; <span class="hljs-number">23</span>;  <span class="hljs-comment">// stream mode</span>

<span class="hljs-keyword">int</span> i = <span class="hljs-number">23</span>;
<span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>];
fs.append(buf, <span class="hljs-number">8</span>);      <span class="hljs-comment">// append 8 bytes</span>
fs.append(&amp;i, <span class="hljs-number">4</span>);       <span class="hljs-comment">// append 4 bytes</span>
fs.append(i);           <span class="hljs-comment">// append 8 bytes, same as fs.append(&amp;i, 4)</span>
fs.append((int16) <span class="hljs-number">23</span>);  <span class="hljs-comment">// append 2 bytes</span>
fs.append(<span class="hljs-string">'c'</span>);         <span class="hljs-comment">// append a single character</span>
fs.append(<span class="hljs-number">100</span>, <span class="hljs-string">'c'</span>);    <span class="hljs-comment">// append 100 character 'c'</span>
fs.append(<span class="hljs-string">'c'</span>, <span class="hljs-number">100</span>);    <span class="hljs-comment">// append 100 character 'c'</span>

fs.c_str();             <span class="hljs-comment">// return a C-style string</span>
fs.str();               <span class="hljs-comment">// return a C++ string with deep-copy</span>
fs.data();              <span class="hljs-comment">// return pointer to data</span>
fs.size();              <span class="hljs-comment">// return data length</span>
fs.capacity();          <span class="hljs-comment">// capacity</span>

fs.reserve(<span class="hljs-number">4096</span>);       <span class="hljs-comment">// reserve at least 4K memory</span>
fs.resize(<span class="hljs-number">32</span>);          <span class="hljs-comment">// size -&gt; 32, content in buffer is unchanged</span>
fs.clear();             <span class="hljs-comment">// size -&gt; 0</span>
fs.swap(fastream());    <span class="hljs-comment">// swap</span>
</div></code></pre>
<ul>
<li>Precautions</li>
</ul>
<p>For performance reasons, no security check is performed during the <code>append</code> operation for <code>fastream</code>. The following code is not safe:</p>
<pre class="hljs"><code><div>fastream f;
f.append(<span class="hljs-string">"hello"</span>);
f.append(f.c_str() + <span class="hljs-number">1</span>); <span class="hljs-comment">// unsafe, internal memory overlap is not considered</span>
</div></code></pre>
<h2 id="8-efficient-strings-fastring">8. Efficient strings (fastring)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fastring.h">co/fastring.h</a>.</p>
<p><code>fastring</code> is a string type in co. Like <code>fastream</code>, it inherits from <code>fast::stream</code>, so in addition to basic string operations, it also supports streaming output operations:</p>
<pre class="hljs"><code><div>fastring s;
s &lt;&lt; <span class="hljs-string">"hello world "</span> &lt;&lt; <span class="hljs-number">1234567</span>;
</div></code></pre>
<p>In the early implementation of fastring, reference counting was used, which made the copying behavior of fastring different from <code>std::string</code>, which caused confusion. To better replace std::string, reference counting has been removed from the refactored version.</p>
<p>Fastring supports almost all operations of fastream, but one thing is different from fastream, fastring will perform security check when <code>append</code>:</p>
<pre class="hljs"><code><div><span class="hljs-function">fastring <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>;
fastream f;
f.append(<span class="hljs-string">"hello"</span>);

s.append(s.c_str() + <span class="hljs-number">1</span>); <span class="hljs-comment">// safe, memory overlap detected, special processing</span>
f.append(f.c_str() + <span class="hljs-number">1</span>); <span class="hljs-comment">// unsafe, does not check memory overlap</span>
</div></code></pre>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div>fastring s;                <span class="hljs-comment">// empty string, without memory allocation</span>
<span class="hljs-function">fastring <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;            <span class="hljs-comment">// empty string, with memory preallocated (32 bytes)</span>
<span class="hljs-function">fastring <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>;       <span class="hljs-comment">// non-empty strings</span>
<span class="hljs-function">fastring <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">88</span>, <span class="hljs-string">'x'</span>)</span></span>;       <span class="hljs-comment">// initialize s to be 88 'x' characters</span>
<span class="hljs-function">fastring <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">'x'</span>, <span class="hljs-number">88</span>)</span></span>;       <span class="hljs-comment">// initialize s to be 88 'x' characters</span>
fastring t = s;            <span class="hljs-comment">// create a new string through memory copy</span>

s &lt;&lt; <span class="hljs-string">"hello "</span> &lt;&lt; <span class="hljs-number">23</span>;       <span class="hljs-comment">// streaming output</span>
s += <span class="hljs-string">"xx"</span>;                 <span class="hljs-comment">// append</span>
s.append(<span class="hljs-string">"xx"</span>);            <span class="hljs-comment">// append  &lt;==&gt;  s += "xx";</span>
s.swap(fastring());        <span class="hljs-comment">// swap</span>

s + <span class="hljs-string">"xxx"</span>;                 <span class="hljs-comment">// +</span>
s &gt; <span class="hljs-string">"xxx"</span>;                 <span class="hljs-comment">// &gt;</span>
s &lt; <span class="hljs-string">"zzz"</span>                  <span class="hljs-comment">// &lt;</span>
s &lt;= <span class="hljs-string">"zz"</span>                  <span class="hljs-comment">// &lt;=</span>
s &gt;= <span class="hljs-string">"zz"</span>                  <span class="hljs-comment">// &gt;=</span>

s.find(<span class="hljs-string">'c'</span>);               <span class="hljs-comment">// character lookup</span>
s.find(<span class="hljs-string">"xx"</span>, <span class="hljs-number">3</span>);           <span class="hljs-comment">// substring lookup starting from index 3</span>
s.rfind(<span class="hljs-string">'c'</span>);              <span class="hljs-comment">// character reverse-lookup</span>
s.rfind(<span class="hljs-string">"xx"</span>);             <span class="hljs-comment">// substring reverse-lookup</span>
s.find_first_of(<span class="hljs-string">"xy"</span>);     <span class="hljs-comment">// find the first occurence of a character in "xy"</span>
s.find_first_not_of(<span class="hljs-string">"xy"</span>); <span class="hljs-comment">// find the first occurence of a character not in "xy"</span>
s.find_last_of(<span class="hljs-string">"xy"</span>);      <span class="hljs-comment">// find the last occurence of a character in "xy"</span>
s.find_last_not_of(<span class="hljs-string">"xy"</span>);  <span class="hljs-comment">// find the last occurence of a character not in "xy"</span>
s.starts_with(<span class="hljs-string">'x'</span>);        <span class="hljs-comment">// check whether s starts with 'x'</span>
s.starts_with(<span class="hljs-string">"xx"</span>);       <span class="hljs-comment">// check whether s starts with "xx"</span>
s.ends_with(<span class="hljs-string">'x'</span>);          <span class="hljs-comment">// check whether s ends with 'x'</span>
s.ends_with(<span class="hljs-string">"xx"</span>);         <span class="hljs-comment">// check whether s ends with "xx"</span>

s.replace(<span class="hljs-string">"xxx"</span>, <span class="hljs-string">"yy"</span>);    <span class="hljs-comment">// replace "xxx" in s with "yy"</span>
s.replace(<span class="hljs-string">"xxx"</span>, <span class="hljs-string">"yy"</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// replace "xxx" in s with "yy" at most 3 times</span>

s.strip();                 <span class="hljs-comment">// strips whitespaces " \t\r\n" from both ends of s</span>
s.strip(<span class="hljs-string">"ab"</span>);             <span class="hljs-comment">// strips 'a', 'b' from both ends of s</span>
s.strip(<span class="hljs-string">"ab"</span>, <span class="hljs-string">'l'</span>);        <span class="hljs-comment">// strips 'a', 'b' from the left endsof s</span>
s.strip(<span class="hljs-string">"ab"</span>, <span class="hljs-string">'r'</span>);        <span class="hljs-comment">// strips 'a', 'b' from the right endsof s</span>

s.<span class="hljs-built_in">tolower</span>();               <span class="hljs-comment">// convert characters in s to lowercases</span>
s.<span class="hljs-built_in">toupper</span>();               <span class="hljs-comment">// convert characters in s to uppercases</span>
s.lower();                 <span class="hljs-comment">// return lowercase of s, without mutating s</span>
s.upper();                 <span class="hljs-comment">// return uppercase of s, without mutating s</span>
s.match(<span class="hljs-string">"x*y?z"</span>);          <span class="hljs-comment">// glob pattern matching</span>
                           <span class="hljs-comment">// '*' for any string, '?' for a single character</span>
</div></code></pre>
<ul>
<li>Precautions</li>
</ul>
<p>When fastring contains binary characters, do not use the <code>find</code> series of operations:</p>
<ul>
<li>find()</li>
<li>rfind()</li>
<li>find_first_of()</li>
<li>find_first_not_of()</li>
<li>find_last_of()</li>
<li>find_last_not_of()</li>
</ul>
<p>The above methods are based on <code>strrchr</code>, <code>strstr</code>, <code>strcspn</code>, <code>strspn</code>, etc. When the string contains binary characters, there is no guarantee that the correct result will be obtained.</p>
<h2 id="9-string-operations">9. String operations</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/str.h">co/str.h</a>.</p>
<h3 id="91-splitting">9.1 Splitting</h3>
<p><code>split</code> splits a string into several pieces.</p>
<ul>
<li>Prototype</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @s: the original string: fastring or const char*</span>
<span class="hljs-comment">// @c: delimiter: a single character or a '\0'-terminated string</span>
<span class="hljs-comment">// @n: allowed times of splitting: 0/-1 means no limit (default is 0)</span>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;fastring&gt; <span class="hljs-title">split</span><span class="hljs-params">(s, c, n=<span class="hljs-number">0</span>)</span></span>;
</div></code></pre>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div>str::split(<span class="hljs-string">"x y z"</span>, <span class="hljs-string">' '</span>);     <span class="hljs-comment">// -&gt;  [ "x", "y", "z" ]</span>
str::split(<span class="hljs-string">"|x|y|"</span>, <span class="hljs-string">'|'</span>);     <span class="hljs-comment">// -&gt;  [ "", "x", "y" ]</span>
str::split(<span class="hljs-string">"xooy"</span>, <span class="hljs-string">"oo"</span>);     <span class="hljs-comment">// -&gt;  [ "x", "y"]</span>
str::split(<span class="hljs-string">"xooy"</span>, <span class="hljs-string">'o'</span>);      <span class="hljs-comment">// -&gt;  [ "x", "", "y" ]</span>
str::split(<span class="hljs-string">"xooy"</span>, <span class="hljs-string">'o'</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// -&gt;  [ "x", "oy" ]</span>
</div></code></pre>
<h3 id="92-stripping">9.2 Stripping</h3>
<p><code>strip</code> strips away certain character on one or both ends of a string, and returns the new string (the original is intact).</p>
<ul>
<li>Prototype</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @s: the original string: fastring or const char*</span>
<span class="hljs-comment">// @c: the set of characters to be stripped: a single character or a string</span>
<span class="hljs-comment">// @d: which end: 'l'/'L' means the left end, 'r'/'R' means the right ends,</span>
<span class="hljs-comment">//                'b' (the default) means both ends</span>
<span class="hljs-function">fastring <span class="hljs-title">strip</span><span class="hljs-params">(s, c=<span class="hljs-string">" \t\r\n"</span>, d=<span class="hljs-string">'b'</span>)</span></span>;
</div></code></pre>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div>str::strip(<span class="hljs-string">"abxxa"</span>, <span class="hljs-string">"ab"</span>);       <span class="hljs-comment">// -&gt; "xx"    strip both ends</span>
str::strip(<span class="hljs-string">"abxxa"</span>, <span class="hljs-string">"ab"</span>, <span class="hljs-string">'l'</span>);  <span class="hljs-comment">// -&gt; "xxa"   strip the left end</span>
str::strip(<span class="hljs-string">"abxxa"</span>, <span class="hljs-string">"ab"</span>, <span class="hljs-string">'r'</span>);  <span class="hljs-comment">// -&gt; "abxx"  strip the right end</span>
</div></code></pre>
<h3 id="93-replacing">9.3 Replacing</h3>
<p><code>replace</code> replaces substrings of the original, and returns the new string (the original is intact).</p>
<ul>
<li>Prototype</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @s:    the original string: fastring or const char*</span>
<span class="hljs-comment">// @sub:  old substring to be replaced</span>
<span class="hljs-comment">// @to:   new substring to be replaced with</span>
<span class="hljs-comment">// @n:    allowed times of replacing: 0/-1 means no limit (default is 0)</span>
<span class="hljs-function">fastring <span class="hljs-title">replace</span><span class="hljs-params">(s, sub, to, n=<span class="hljs-number">0</span>)</span></span>;
</div></code></pre>
<ul>
<li>Examples</li>
</ul>
<pre class="hljs"><code><div>str::replace(<span class="hljs-string">"xooxoox"</span>, <span class="hljs-string">"oo"</span>, <span class="hljs-string">"ee"</span>);     <span class="hljs-comment">// -&gt; "xeexeex"</span>
str::replace(<span class="hljs-string">"xooxoox"</span>, <span class="hljs-string">"oo"</span>, <span class="hljs-string">"ee"</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// -&gt; "xeexoox"</span>
</div></code></pre>
<h3 id="94-string-to-built-in-types">9.4 String to built-in types</h3>
<p>The library provides the following strings to convert a string into primitive types:</p>
<pre class="hljs"><code><div>to_int32  to_int64  to_uint32  to_uint64  to_bool  to_double
</div></code></pre>
<ul>
<li>
<p>Notes</p>
<ul>
<li>if conversion errs, throw an exception of <code>const char*</code> type</li>
<li>when converting to integers, the parameter could end with unit <code>k</code>, <code>m</code>, <code>g</code>, <code>t</code>, <code>p</code> (case-insensitive).</li>
</ul>
</li>
<li>
<p>Examples</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> x = str::to_bool(<span class="hljs-string">"false"</span>);    <span class="hljs-comment">// "true" or "1" -&gt; true</span>
                                   <span class="hljs-comment">// "false" or "0" -&gt; false</span>
<span class="hljs-keyword">double</span> x = str::to_double(<span class="hljs-string">"3.14"</span>); <span class="hljs-comment">// 3.14</span>

int32 x = str::to_int32(<span class="hljs-string">"-23"</span>);    <span class="hljs-comment">// -23</span>
int64 x = str::to_int64(<span class="hljs-string">"4k"</span>);     <span class="hljs-comment">// 4096</span>
uint32 x = str::to_uint32(<span class="hljs-string">"8M"</span>);   <span class="hljs-comment">// 8 &lt;&lt; 20</span>
uint64 x = str::to_uint64(<span class="hljs-string">"8T"</span>);   <span class="hljs-comment">// 8ULL &lt;&lt; 40</span>
</div></code></pre>
<h3 id="95-built-in-types-to-string">9.5 Built-in types to string</h3>
<p>The library provides function <code>from</code> to convert a built-in type to string.</p>
<ul>
<li>Examples:</li>
</ul>
<pre class="hljs"><code><div>fastring s = str::from(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// -&gt; "true"</span>
fastring s = str::from(<span class="hljs-number">23</span>);    <span class="hljs-comment">// -&gt; "23"</span>
fastring s = str::from(<span class="hljs-number">3.14</span>);  <span class="hljs-comment">// -&gt; "3.14"</span>
</div></code></pre>
<h3 id="96-debug-string">9.6 debug string</h3>
<p>The library provides function <code>dbg</code> to convert an object to a string for debugging.</p>
<ul>
<li>Prototype</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @v: built-in types, sttings, or common STL containers (vector, map, set)</span>
fastring dbg&lt;T&gt;(v);
</div></code></pre>
<ul>
<li>Example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m { {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">2</span>} };
str::dbg(v);    <span class="hljs-comment">// -&gt; "[1,2,3]"</span>
str::dbg(s);    <span class="hljs-comment">// -&gt; "{1,2,3}"</span>
str::dbg(m);    <span class="hljs-comment">// -&gt; "{1:1,2:2}</span>

str::dbg(<span class="hljs-literal">true</span>); <span class="hljs-comment">// -&gt; "true"</span>
str::dbg(<span class="hljs-number">23</span>);   <span class="hljs-comment">// -&gt; "23"</span>
str::dbg(<span class="hljs-string">"23"</span>); <span class="hljs-comment">// -&gt; "\"23\"", string, with quotes added</span>
</div></code></pre>
<ul>
<li>If the parameter string contains <code>&quot;</code>, the returned string from <code>dbg()</code> may look weird. But it is fine in most cases since the function is used to print logs.</li>
</ul>
<h2 id="10-commandline-arguments-and-config-file-parsing-flag">10. Commandline arguments and config file parsing (flag)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/flag.h">co/flag.h</a>.</p>
<h3 id="101-concepts">10.1 Concepts</h3>
<p>Library <code>flag</code> is a commandline arguments and configuration file parser like <a href="https://github.com/gflags/gflags">google gflags</a>. The code defines static global variables, and parses commandline arguments and configuration file at runtime, and modifies the value of these variables accordingly.</p>
<h4 id="1011-flag-variables">10.1.1 flag variables</h4>
<p><strong>flag variables</strong> refer to the static global variables defined by macros in this library. For example, the code snippet below defines a flag variable named <code>x</code>, and its corresponding global variable is named <code>FLG_x</code>.</p>
<pre class="hljs"><code><div>DEF_bool(x, <span class="hljs-literal">false</span>, <span class="hljs-string">"xxx"</span>); <span class="hljs-comment">// bool FLG_x = false;</span>
</div></code></pre>
<p>The library supports 7 types of flag variables:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span>, int32, int64, uint32, uint64, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>
</div></code></pre>
<h4 id="1012-command-line-flags">10.1.2 command line flags</h4>
<p>Strings in commandline arguments often take the form of <code>-x=y</code>. Here, <code>x</code> is a <strong>commandline flag</strong> (<strong>flag</strong> below). Flags in the commandline and flag variables in the code are one-to-one mapped to each other. The library is flexible for ease of using:</p>
<ul>
<li>the leading <code>-</code> can be omitted from <code>-x=y</code>, so you can write <code>x=y</code>.</li>
<li><code>-x=y</code> can be also writen as <code>-x y</code>.</li>
<li>the number of <code>-</code> before <code>x=y</code> is unlimited.</li>
<li>for boolean flags, <code>-b=true</code> can be abbreviated as <code>-b</code> (the leading <code>-</code> must be kept when using this abbreviation).</li>
</ul>
<pre class="hljs"><code><div>./exe -b -i=32 s=hello xx  <span class="hljs-comment"># b,i,s are flags, but xx is not</span>
</div></code></pre>
<h3 id="102-initialization-of-flag-library">10.2 initialization of flag library</h3>
<p>The library provides only one API <code>flag::init()</code>. It is used to initialize the library and parses commandline arguments and config files.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Workflow</span>
<span class="hljs-comment">// 1. Scan commandline arguments, and divide it into flag and non-flag.</span>
<span class="hljs-comment">// 2. Update the value of FLG_config according to the flag arguments. </span>
<span class="hljs-comment">//    If it is not empty, parse the given config file.</span>
<span class="hljs-comment">// 3. Update the values of other flag variables based on the flag arguments.</span>
<span class="hljs-comment">// 4. If FLG_mkconf is not empty, generate a config file and exit.</span>
<span class="hljs-comment">// 5. if FLG_daemon is true, run the program in the background.</span>

<span class="hljs-comment">// If an error is encountered while parsing, output an error message and exit.</span>
<span class="hljs-comment">// If no error is encountered, return a list of non-flag arguments.</span>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;fastring&gt; <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;
</div></code></pre>
<p>This function needs to be called upon entering <code>main()</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/flag.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{
    flag::init(argc, argv);
}
</div></code></pre>
<h3 id="103-define-declare-and-use-flag-variables">10.3 Define, declare, and use flag variables</h3>
<h4 id="1031-define-flag-variables">10.3.1 Define flag variables</h4>
<p>This library implements 7 macros to define 7 different flag variable types:</p>
<pre class="hljs"><code><div>DEF_bool  DEF_int32  DEF_int64  DEF_uint32  DEF_uint64  DEF_double  DEF_string
</div></code></pre>
<p>The snippet below defines two types of flag variables; one is boolean and the other is string:</p>
<pre class="hljs"><code><div>DEF_bool(b, <span class="hljs-literal">false</span>, <span class="hljs-string">"comments"</span>);  <span class="hljs-comment">// bool FLG_b = false;</span>
DEF_string(s, <span class="hljs-string">"x"</span>, <span class="hljs-string">"comments"</span>);  <span class="hljs-comment">// fastring FLG_s = "x";</span>
</div></code></pre>
<p>Macro <code>DEF_xxx</code> has three parameter: the first is the flag variable name, the second is the default value, and the third is the comments. Note that:</p>
<ul>
<li>the flag variable is global, and thus they shouldn't be defined in a header,</li>
<li>the name of the flag variable should be unique.</li>
</ul>
<h4 id="1032-declare-flag-variables">10.3.2 Declare flag variables</h4>
<p>This library also implements 7 macros to define 7 different flag variable types:</p>
<pre class="hljs"><code><div>DEC_bool  DEC_int32  DEC_int64  DEC_uint32  DEC_uint64  DEC_double  DEC_string
</div></code></pre>
<p>The snippet below declares a variable of <code>int32</code>:</p>
<pre class="hljs"><code><div>DEC_int32(i32); <span class="hljs-comment">// extern int32 FLG_i32;</span>
</div></code></pre>
<p>Macro <code>DEC_xxx</code> has only one parameter, which is the flag variable name. Each variable can only be defined once, but can be declared multiple times. Declarations are generally used to refer to flag variables defined elsewhere.</p>
<h4 id="1033-use-flag-variables">10.3.3 Use flag variables</h4>
<p>After being defined or declared, the flag variables can be used like ordinary variables:</p>
<pre class="hljs"><code><div>DEC_bool(b);
<span class="hljs-keyword">if</span> (!FLG_b) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b is false"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;   

DEF_string(s, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"xxx"</span>);
FLG_s += <span class="hljs-string">" world"</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; FLG_s &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</div></code></pre>
<h3 id="104-use-flags-in-commandline">10.4 Use flags in commandline</h3>
<h4 id="1041-set-flag-variables-values-in-commandline">10.4.1 Set flag variables' values in commandline:</h4>
<p>Assume the program defines the following flags:</p>
<pre class="hljs"><code><div>DEF_bool(x, <span class="hljs-literal">false</span>, <span class="hljs-string">"bool x"</span>);
DEF_bool(y, <span class="hljs-literal">false</span>, <span class="hljs-string">"bool y"</span>);
DEF_int32(i, <span class="hljs-number">-32</span>, <span class="hljs-string">"int32"</span>);
DEF_uint64(u, <span class="hljs-number">64</span>, <span class="hljs-string">"uint64"</span>);
DEF_double(d, <span class="hljs-number">3.14</span>, <span class="hljs-string">"double"</span>);
DEF_string(s, <span class="hljs-string">"hello world"</span>, <span class="hljs-string">"string"</span>);
</div></code></pre>
<p>The flags' values can be modified in commandline:</p>
<ul>
<li>
<p><code>-x=y</code> can be also writen as <code>-x y</code> or <code>x=y</code></p>
<pre class="hljs"><code><div>./xx -i=8 u=88 -s=<span class="hljs-string">"hello world"</span>
./xx -i 8 -u 88 -s <span class="hljs-string">"hello world"</span>
</div></code></pre>
</li>
<li>
<p>For boolean flags, the <code>true</code> value can be omitted</p>
<pre class="hljs"><code><div>./xx -x     <span class="hljs-comment"># -x=true</span>
</div></code></pre>
</li>
<li>
<p>When multiple boolean flags are set to <code>true</code> and their names are single characters, they can be combined</p>
<pre class="hljs"><code><div>./xx -xy    <span class="hljs-comment"># -x=true -y=true</span>
</div></code></pre>
</li>
<li>
<p>Integer flags can have a trailing unit symbol <code>k</code>, <code>m</code>, <code>g</code>, <code>t</code>, or <code>p</code> (case-insensitive).</p>
<pre class="hljs"><code><div>./xx i=-4k  <span class="hljs-comment"># i=-4096</span>
</div></code></pre>
</li>
<li>
<p>Integer flags' values can also be octal or hexadecimal</p>
<pre class="hljs"><code><div>./xx i=032  <span class="hljs-comment"># i=26    octal</span>
./xx u=0xff <span class="hljs-comment"># u=255   hexadecimal</span>
</div></code></pre>
</li>
</ul>
<h4 id="1042-help-messages">10.4.2 Help messages</h4>
<pre class="hljs"><code><div>$ ./xx --<span class="hljs-built_in">help</span>
usage:
    ./xx --                   <span class="hljs-built_in">print</span> flags info
    ./xx --<span class="hljs-built_in">help</span>               <span class="hljs-built_in">print</span> this <span class="hljs-built_in">help</span> info
    ./xx --mkconf             generate config file
    ./xx --daemon             run as a daemon (Linux)
    ./xx xx.conf              run with config file
    ./xx config=xx.conf       run with config file
    ./xx -x -i=8k -s=ok       run with commandline flags
    ./xx -x -i 8k -s ok       run with commandline flags
    ./xx x=<span class="hljs-literal">true</span> i=8192 s=ok   run with commandline flags
</div></code></pre>
<h4 id="1043-flag-variable-list">10.4.3 Flag variable list</h4>
<pre class="hljs"><code><div>$ ./xx --
--config: .path of config file
	 <span class="hljs-built_in">type</span>: string	     default: <span class="hljs-string">""</span>
	 from: ../../base/flag.cc
--mkconf: .generate config file
	 <span class="hljs-built_in">type</span>: bool	     default: <span class="hljs-literal">false</span>
	 from: ../../base/flag.cc
</div></code></pre>
<h3 id="105-specify-a-config-file-for-program">10.5 Specify a config file for program</h3>
<p>A configuration file can be specified for a program with flag <code>config</code>:</p>
<pre class="hljs"><code><div>./xx config=xx.conf
./xx xx.conf    <span class="hljs-comment"># if the config file name ends with '.conf' or 'config' and</span>
                <span class="hljs-comment"># it's the first non-flag parameter, config= can be omitted </span>
./xx -x xx.conf <span class="hljs-comment"># -x is a flag, so xx.conf is the first non-flag parameter</span>
</div></code></pre>
<p>Also, the config file can be specified by modifying the value of <code>FLG_config</code> before invoking <code>flag::init()</code>.</p>
<h3 id="106-auto-generate-config-files">10.6 Auto-generate config files</h3>
<p>A config file can be auto-generated by using <code>--mkconf</code>:</p>
<pre class="hljs"><code><div>./xx --mkconf          <span class="hljs-comment"># generate xx.conf in the same directory of xx</span>
./xx --mkconf -x u=88  <span class="hljs-comment"># replace default values with specified values</span>
</div></code></pre>
<p>Configuration items are sorted by level, file name, and line number of code. When defining the flag, you can add <code>#n</code> at the beginning of the comments to specify the level. <code>n</code> must be an integer between 0 and 99. If not specified, it defaults to 10.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Specify the level as 0 (the lower level ranks first)</span>
DEF_bool (daemon, <span class="hljs-literal">false</span>, <span class="hljs-string">"# 0 run program as a daemon"</span>);
</div></code></pre>
<ul>
<li>Special notes:
<ul>
<li>Flags whose comments start with <code>.</code> are <strong>hidden</strong> and will not be present in the generated config file, but <code>./xx --</code> still displays them.</li>
<li>Flag whose comments are empty are <strong>stealth</strong>, which means they will not be present in the generated config file, and won't be displayed by <code>./xx --</code>.</li>
</ul>
</li>
</ul>
<h3 id="107-format-of-config-files">10.7 Format of config files</h3>
<p>THe library allows a flexible format for config files:</p>
<ul>
<li>Ignore whitespaces before or at the end of lines, so manually writing them is freer and less error-prone.</li>
<li><code>#</code> and <code>//</code> stands for comments. Block comments and trailing comments are supported.</li>
<li>each line has at most one flag, in the form of <code>x = y</code> for clarity.</li>
<li>One or more whitespaces can be inserted before or after <code>=</code>.</li>
<li>Lines can be concatenated with <code>\</code> at the end of the previous line.</li>
<li>No escaping is supported to prevent ambiguity.</li>
</ul>
<p>An example:</p>
<pre class="hljs"><code><div>   <span class="hljs-comment"># config file: xx.conf</span>
     daemon = <span class="hljs-literal">false</span>            <span class="hljs-comment"># background program (defined in co/flag)</span>
     boo = <span class="hljs-literal">true</span>                <span class="hljs-comment"># cannot be simplified as '-boo'</span>

     s =                       <span class="hljs-comment"># empty string</span>
     s = hello \
         world                 <span class="hljs-comment"># s = "helloworld"</span>
     s = <span class="hljs-string">"http://github.com"</span>   <span class="hljs-comment"># '#' and '//' are not comments in a quoted string</span>
     s = <span class="hljs-string">"I'm ok"</span>              <span class="hljs-comment"># string, use double quotes on both ends</span>
     s = <span class="hljs-string">'how are "U"'</span>         <span class="hljs-comment"># string, use single quotes on both ends</span>
     i32 = 4k                  <span class="hljs-comment"># 4096, support unit: k,m,g,t,p (case-insensitive)</span>
     i32 = 032                 <span class="hljs-comment"># octal, i32 = 26</span>
     i32 = 0xff                <span class="hljs-comment"># hexadecima, i32 = 255</span>
     pi = 3.14159              <span class="hljs-comment"># double type</span>
</div></code></pre>
<h2 id="11-efficient-streaming-log-library-log">11. Efficient streaming log library (log)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/log.h">co/log.h</a>.</p>
<h3 id="111-basic-introduction">11.1 Basic introduction</h3>
<p>The <code>log</code> library is a C++ streaming log library similar to <a href="https://github.com/google/glog">google glog</a>. Printing logs is more convenient and safer than the printf series of functions:</p>
<pre class="hljs"><code><div>LOG &lt;&lt; <span class="hljs-string">"hello world"</span> &lt;&lt; <span class="hljs-number">23</span>;
</div></code></pre>
<p>The internal implementation of the log library uses an asynchronous method. Logs are first written to the cache. After a certain amount or more than a certain time, the background thread writes all logs to the file together. The performance is improved by 20 to 150 times compared to glog on different platforms.</p>
<p>The following table is the test result of continuously printing 1 million (about 50 bytes each) info level logs on different platforms:</p>
<table>
<thead>
<tr>
<th>log vs glog</th>
<th>google glog</th>
<th>co/log</th>
</tr>
</thead>
<tbody>
<tr>
<td>win2012 HDD</td>
<td>1.6MB/s</td>
<td>180MB/s</td>
</tr>
<tr>
<td>win10 SSD</td>
<td>3.7MB/s</td>
<td>560MB/s</td>
</tr>
<tr>
<td>mac SSD</td>
<td>17MB/s</td>
<td>450MB/s</td>
</tr>
<tr>
<td>linux SSD</td>
<td>54MB/s</td>
<td>1023MB/s</td>
</tr>
</tbody>
</table>
<h3 id="112-api-introduction">11.2 Api Introduction</h3>
<p>The log library provides only two API functions:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;
</div></code></pre>
<p><code>log:: init()</code> needs to be called once at the beginning of the <code>main</code> function. Since the log library depends on the flag library, the main function is generally written as follows:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/flag.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/log.h"</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{
    flag::init(argc, argv);
    <span class="hljs-built_in">log</span>::init();
}
</div></code></pre>
<p><code>log::close()</code> writes logs in the cache to a file, and exits the logging thread. The log library internally captures signals such as <code>SIGINT, SIGTERM, SIGQUIT</code>, and writes all cached logs to the log file before the program exits.</p>
<h3 id="113-print-different-levels-of-logs">11.3 Print different levels of logs</h3>
<p>Logs are divided into 5 levels: debug, info, warning, error and fatal. You can use the macros DLOG, LOG, WLOG, ELOG and FLOG to print 5 different levels of logs:</p>
<pre class="hljs"><code><div>DLOG &lt;&lt; <span class="hljs-string">"this is DEBUG log "</span> &lt;&lt; <span class="hljs-number">23</span>;
LOG &lt;&lt; <span class="hljs-string">"this is INFO log "</span> &lt;&lt; <span class="hljs-number">23</span>;
WLOG &lt;&lt; <span class="hljs-string">"this is WARNING log "</span> &lt;&lt; <span class="hljs-number">23</span>;
ELOG &lt;&lt; <span class="hljs-string">"this is ERROR log "</span> &lt;&lt; <span class="hljs-number">23</span>;
FLOG &lt;&lt; <span class="hljs-string">"this is FATAL log "</span> &lt;&lt; <span class="hljs-number">23</span>;
</div></code></pre>
<p>Print the <code>fatal</code> log, which generally indicates that a fatal error occurred in the program. The log library will print the stacktrace information of the current thread and terminate the running of the program.</p>
<h3 id="114-conditional-log-logif">11.4 Conditional log (LOG_IF)</h3>
<p>The log library also provides the <code>IF</code> version of the macro, which accepts a conditional parameter and prints the log when the specified condition is met.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>DLOG_IF(cond) &lt;&lt; <span class="hljs-string">"this is DEBUG log "</span> &lt;&lt; <span class="hljs-number">23</span>;
LOG_IF(cond) &lt;&lt; <span class="hljs-string">"this is INFO log "</span> &lt;&lt; <span class="hljs-number">23</span>;
WLOG_IF(cond) &lt;&lt; <span class="hljs-string">"this is WARNING log "</span> &lt;&lt; <span class="hljs-number">23</span>;
ELOG_IF(cond) &lt;&lt; <span class="hljs-string">"this is ERROR log "</span> &lt;&lt; <span class="hljs-number">23</span>;
FLOG_IF(cond) &lt;&lt; <span class="hljs-string">"this is FATAL log "</span> &lt;&lt; <span class="hljs-number">23</span>;
</div></code></pre>
<h3 id="115-print-log-every-n-times-logeveryn">11.5 Print log every N times (LOG_EVERY_N)</h3>
<p>The log library provides <code>LOG_EVERY_N</code> and other macros that support printing logs every N times. These macros use atomic operations internally to ensure thread safety.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// print log 1, 33, 65......</span>
DLOG_EVERY_N(<span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-string">"this is DEBUG log "</span> &lt;&lt; <span class="hljs-number">23</span>;
LOG_EVERY_N(<span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-string">"this is INFO log "</span> &lt;&lt; <span class="hljs-number">23</span>;
WLOG_EVERY_N(<span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-string">"this is WARNING log "</span> &lt;&lt; <span class="hljs-number">23</span>;
ELOG_EVERY_N(<span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-string">"this is ERROR log "</span> &lt;&lt; <span class="hljs-number">23</span>;
</div></code></pre>
<p>FLOG does not have this function because the program is dead as soon as FLOG prints.</p>
<h3 id="116-print-the-first-n-logs-logfirstn">11.6 Print the first N logs (LOG_FIRST_N)</h3>
<p>The log library provides <code>LOG_FIRST_N</code> and other macros to support printing the first N logs, these macros also use atomic operations internally to ensure thread safety.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// print the first 10 logs</span>
DLOG_FIRST_N(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"this is DEBUG log "</span> &lt;&lt; <span class="hljs-number">23</span>;
LOG_FIRST_N(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"this is INFO log "</span> &lt;&lt; <span class="hljs-number">23</span>;
WLOG_FIRST_N(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"this is WARNING log "</span> &lt;&lt; <span class="hljs-number">23</span>;
ELOG_FIRST_N(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">"this is ERROR log "</span> &lt;&lt; <span class="hljs-number">23</span>;
</div></code></pre>
<h3 id="117-check-enhanced-assert">11.7 CHECK: Enhanced assert</h3>
<p>The log library provides a series of CHECK macros, which can be regarded as enhanced asserts. These macros will not be cleared in DEBUG mode.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>CHECK(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> == <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">"say something here"</span>;
CHECK_EQ(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// ==</span>
CHECK_NE(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// !=</span>
CHECK_GE(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// &gt;=</span>
CHECK_LE(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// &lt;=</span>
CHECK_GT(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// &gt;  greater than</span>
CHECK_LT(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// &lt;  less than</span>
</div></code></pre>
<p>When CHECK failed, the LOG library will first call <code>log::close()</code> to write the logs, then print the stacktrace information of the current thread, and then exit the program.</p>
<h3 id="118-configuration-items">11.8 Configuration items</h3>
<ul>
<li>
<p>log_dir</p>
<p>Specifies the log directory. The default is the <code>logs</code> directory under the current directory. It will be created automatically if it does not exist.</p>
<pre class="hljs"><code><div>DEF_string(log_dir, <span class="hljs-string">"logs"</span>, <span class="hljs-string">"Log dir, will be created if not exists"</span>);
</div></code></pre>
</li>
<li>
<p>log_file_name</p>
<p>Specify the log file name (without path), which is empty by default, and use the program name as the log file name.</p>
<pre class="hljs"><code><div>DEF_string(log_file_name, <span class="hljs-string">""</span>, <span class="hljs-string">"name of log file, using exename if empty"</span>);
</div></code></pre>
</li>
<li>
<p>min_log_level</p>
<p>Specifies the minimum level of printing logs, which is used to disable low-level logs. The default is 0, and logs of all levels are printed.</p>
<pre class="hljs"><code><div>DEF_int32(min_log_level, <span class="hljs-number">0</span>, <span class="hljs-string">"write logs at or above this level, 
                             0-4 (debug|info|warning|error|fatal)"</span>);
</div></code></pre>
</li>
<li>
<p>max_log_file_size</p>
<p>Specifies the maximum size of the log file. The default size is 256M. If the file size exceeds this size, a new log file is generated and the old log file is renamed.</p>
<pre class="hljs"><code><div>DEF_int64(max_log_file_size, <span class="hljs-number">256</span> &lt;&lt; <span class="hljs-number">20</span>, <span class="hljs-string">"max size of log file, 
                                         default: 256MB"</span>);
</div></code></pre>
</li>
<li>
<p>max_log_file_num</p>
<p>Specifies the maximum number of log files. The default is 8. If this value is exceeded, old log files are deleted.</p>
<pre class="hljs"><code><div>DEF_uint32(max_log_file_num, <span class="hljs-number">8</span>, <span class="hljs-string">"max number of log files"</span>);
</div></code></pre>
</li>
<li>
<p>max_log_buffer_size</p>
<p>Specifies the maximum size of the log cache. The default value is 32M. If this value is exceeded, half of the logs are discarded.</p>
<pre class="hljs"><code><div>DEF_uint32(max_log_buffer_size, <span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>, <span class="hljs-string">"max size of log buffer, default: 32MB"</span>);
</div></code></pre>
</li>
<li>
<p>cout</p>
<p>Terminal log switch. The default is false. If true, also logging to the terminal.</p>
<pre class="hljs"><code><div>DEF_bool (<span class="hljs-built_in">cout</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">"also logging to terminal"</span>);
</div></code></pre>
</li>
</ul>
<h3 id="119-functional-and-performance-test">11.9 Functional and performance test</h3>
<p>The test code of the log library can be found in <a href="https://github.com/idealvin/co/blob/master/test/log_test.cc">test/log_test.cc</a>.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># run following commands in the root dir of co</span>
xmake -b <span class="hljs-built_in">log</span>    <span class="hljs-comment"># build log</span>

<span class="hljs-comment"># print different types of logs</span>
xmake r <span class="hljs-built_in">log</span>

<span class="hljs-comment"># also logging to terminal</span>
xmake r <span class="hljs-built_in">log</span> -cout

<span class="hljs-comment"># min_log_level specify the minimum level of output logs</span>
xmake r <span class="hljs-built_in">log</span> -min_log_level=1   <span class="hljs-comment"># 0-4: debug,info,warning,error,fatal </span>

<span class="hljs-comment"># performance test, one thread continuously prints 1 million info-level logs</span>
xmake r <span class="hljs-built_in">log</span> -perf
</div></code></pre>
<h2 id="12-unit-testing-framework-unitest">12. Unit testing framework (unitest)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/unitest.h">co/unitest.h</a>.</p>
<p><code>unitest</code> is a unit testing framework similar to <a href="https://github.com/google/googletest">google gtest</a>, but easier to use.</p>
<h3 id="121-define-test-units-and-use-cases">12.1 Define test units and use cases</h3>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/unitest.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/os.h"</span></span>

<span class="hljs-comment">// Define a test unit named os with 3 different test cases.</span>
<span class="hljs-comment">// When running the unitest program, the parameter -os can be specified </span>
<span class="hljs-comment">// to run only test cases in os.</span>
DEF_test(os) {
    DEF_case(homedir) {
        EXPECT_NE(os::homedir(), <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>());
    }

    DEF_case(pid) {
        EXPECT_GE(os::pid(), <span class="hljs-number">0</span>);
    }

    DEF_case(cpunum) {
        EXPECT_GT(os::cpunum(), <span class="hljs-number">0</span>);
    }
}
</div></code></pre>
<h3 id="122-run-test-case">12.2 Run test case</h3>
<p>There are some unit test codes under <a href="https://github.com/idealvin/co/tree/master/unitest">co/unitest</a>, which can be compiled and executed as follows:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># run following commands in the root dir of co</span>
xmake -b unitest    <span class="hljs-comment"># build unitest or unitest.exe </span>

<span class="hljs-comment"># run all test cases</span>
xmake r unitest -a

<span class="hljs-comment"># run only test cases in os unit</span>
xmake r unitest -os
</div></code></pre>
<h2 id="13-time-library-time">13. Time library (time)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/time.h">co/time.h</a>.</p>
<h3 id="131-monotonic-time">13.1 monotonic time</h3>
<p><code>monotonic time</code> is implemented on most platforms as the time since system startup. It is generally used for timing, which is more stable than system time and is not affected by system time.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>int64 us = now::us(); <span class="hljs-comment">// Microsecond</span>
int64 ms = now::ms(); <span class="hljs-comment">// Millisecond</span>
</div></code></pre>
<h3 id="132-time-string-nowstr">13.2 Time string (now::str())</h3>
<p><code>now::str()</code> is based on <code>strftime</code> and returns a string representation of the current system time in the specified format.</p>
<ul>
<li>Function prototype</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// fm: time output format</span>
<span class="hljs-function">fastring <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fm=<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>)</span></span>;
</div></code></pre>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>fastring s = now::str();     <span class="hljs-comment">// "2018-08-08 08:08:08"</span>
fastring s = now::str(<span class="hljs-string">"%Y"</span>); <span class="hljs-comment">// "2028"</span>
</div></code></pre>
<h3 id="133-sleep">13.3 sleep</h3>
<p>The Linux platform supports microsecond-level sleep, but it is difficult to implement on Windows. Therefore, only millisecond, second-level sleep is supported in this library.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>sleep::ms(<span class="hljs-number">10</span>); <span class="hljs-comment">// sleep for 10 milliseconds</span>
sleep::sec(<span class="hljs-number">1</span>); <span class="hljs-comment">// sleep for 1 second</span>
</div></code></pre>
<h3 id="134-timertimer">13.4 Timer(Timer)</h3>
<p><code>Timer</code> is based on monotonic time. When a Timer object is created, it starts timing.</p>
<pre class="hljs"><code><div>Timer t;
sleep::ms(<span class="hljs-number">10</span>);

int64 us = t.us(); <span class="hljs-comment">// Microsecond</span>
int64 ms = t.ms(); <span class="hljs-comment">// Millisecond</span>

t.restart();       <span class="hljs-comment">// Restart timing</span>
</div></code></pre>
<h2 id="14-thread-library-thread">14. Thread library (thread)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/thread.h">co/thread.h</a>.</p>
<h3 id="141-mutex">14.1 Mutex</h3>
<p><code>Mutex</code> is a mutex commonly used in multi-threaded programming. At the same time, at most one thread owns the lock, and other threads must wait for the lock to be released.</p>
<p>There is also a kind of read-write lock, which allows multiple threads to read at the same time, but at most only one thread can write. In practical applications, its performance is poor, so this library has removed the read-write lock.</p>
<p>Corresponding to <code>Mutex</code>, there is a<code> MutexGuard</code> class for automatic acquisition and release of mutex locks.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>Mutex m;
m.lock();         <span class="hljs-comment">// Acquire the lock</span>
m.unlock();       <span class="hljs-comment">// Release the lock</span>
m.try_lock();     <span class="hljs-comment">// Acquire the lock</span>

<span class="hljs-function">MutexGuard <span class="hljs-title">g</span><span class="hljs-params">(m)</span></span>;  <span class="hljs-comment">// Call m.lock () in the constructor, </span>
                  <span class="hljs-comment">// and call m.unlock () in the destructor.</span>
</div></code></pre>
<h3 id="142-syncevent">14.2 SyncEvent</h3>
<p><code>SyncEvent</code> is a synchronization mechanism commonly used in multi-threaded programming and is suitable for the producer-consumer model.</p>
<ul>
<li>SyncEvent constructor description</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// manual_reset: whether to manually reset the synchronization status of events</span>
<span class="hljs-comment">// signaled:     whether the initial state of the event is signaled</span>
SyncEvent(<span class="hljs-keyword">bool</span> manual_reset=<span class="hljs-literal">false</span>, <span class="hljs-keyword">bool</span> signaled=<span class="hljs-literal">false</span>);
</div></code></pre>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>SyncEvent ev;
ev.wait();                 <span class="hljs-comment">// Thread A, waiting for event synchronization, </span>
                           <span class="hljs-comment">// automatically reset the event to unsignaled.</span>
ev.signal();               <span class="hljs-comment">// Thread B, event synchronization notification</span>

<span class="hljs-function">SyncEvent <span class="hljs-title">ev</span><span class="hljs-params">(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// Enable manual_reset, waiting threads need </span>
                           <span class="hljs-comment">// set synchronization status manually </span>
ev.wait(<span class="hljs-number">1000</span>);             <span class="hljs-comment">// Thread A, waiting 1000 milliseconds until </span>
                           <span class="hljs-comment">//the event is synchronized or timed out</span>
ev.reset();                <span class="hljs-comment">// Thread A, manually set event status to unsignaled</span>
ev.signal();               <span class="hljs-comment">// Thread B, event synchronization notification</span>
</div></code></pre>
<h3 id="143-thread">14.3 Thread</h3>
<p>The <code>Thread</code> class is a wrapper around a thread. When a Thread object is created, the thread is started, and when the thread function ends, the thread automatically exits.</p>
<p>In addition to the constructor and destructor, the Thread class provides only two methods:</p>
<ul>
<li>
<p><code>join()</code>, will block and wait for the thread function to finish executing, and then exit the thread.</p>
</li>
<li>
<p><code>detach()</code>, will not block, system resources are automatically released when the thread function ends.</p>
</li>
<li>
<p>Code example</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// start thread</span>
<span class="hljs-function">Thread <span class="hljs-title">x</span><span class="hljs-params">(f)</span></span>;                        <span class="hljs-comment">// void f();</span>
<span class="hljs-function">Thread <span class="hljs-title">x</span><span class="hljs-params">(f, p)</span></span>;                     <span class="hljs-comment">// void f(void*);  void* p;</span>
<span class="hljs-function">Thread <span class="hljs-title">x</span><span class="hljs-params">(&amp;T::f, &amp;t)</span></span>;                <span class="hljs-comment">// void T::f();  T t;</span>
<span class="hljs-function">Thread <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bind(f, <span class="hljs-number">7</span>))</span></span>;          <span class="hljs-comment">// void f(int v);</span>
<span class="hljs-function">Thread <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::bind(&amp;T::f, &amp;t, <span class="hljs-number">7</span>))</span></span>;  <span class="hljs-comment">// void T::f(int v);  T t;</span>

<span class="hljs-comment">// Block, wait for the thread function to finish executing</span>
x.join();                           

<span class="hljs-comment">// Starts the thread and destroys the Thread object.</span>
<span class="hljs-comment">// The thread runs independently of the Thread object.</span>
Thread(f).detach();
</div></code></pre>
<h3 id="144-get-the-id-of-the-current-thread">14.4 Get the id of the current thread</h3>
<p><code>current_thread_id ()</code> is used to get the id of the current thread. The thread library uses [TLS] (https://wiki.osdev.org/Thread_Local_Storage) to save the thread id. Each thread only needs one system call.</p>
<ul>
<li>Notes</li>
</ul>
<p>The Linux glibc has added the <code>gettid</code> system call since <code>2.30</code>. To avoid conflicts, the thread library has removed the earlier provided <code>gettid</code> interface and changed it to<code> current_thread_id</code>.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> id = current_thread_id();
</div></code></pre>
<h3 id="145-threadptr-based-on-tls">14.5 thread_ptr based on TLS</h3>
<p><code>thread_ptr</code> is similar to<code>std::unique_ptr</code>, but uses the <code>TLS</code> mechanism internally. Each thread sets and has its own ptr.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">T</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; current_thread_id() &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

thread_ptr&lt;T&gt; pt;

<span class="hljs-comment">// Executed in the thread function of thread 1</span>
<span class="hljs-keyword">if</span> (pt == <span class="hljs-literal">NULL</span>) pt.reset(<span class="hljs-keyword">new</span> T); 
pt-&gt;run();  <span class="hljs-comment">// Print id of thread 1</span>

<span class="hljs-comment">// Executed in a thread function in thread 2</span>
<span class="hljs-keyword">if</span> (pt == <span class="hljs-literal">NULL</span>) pt.reset(<span class="hljs-keyword">new</span> T);
pt-&gt;run();  <span class="hljs-comment">// Print id of thread 2</span>
</div></code></pre>
<h3 id="146-timed-task-scheduler-tasksched">14.6 Timed task scheduler (TaskSched)</h3>
<p>The <code>TaskSched</code> class is used for scheduling scheduled tasks. All tasks are scheduled by a single thread internally, but tasks can be added from any thread.</p>
<ul>
<li>Methods provided by TaskSched
<ul>
<li>run_in</li>
<li>run_every</li>
<li>run_daily</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// @f: std::function&lt;void()&gt; type function object</span>

<span class="hljs-comment">// run f once after n seconds</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_in</span><span class="hljs-params">(f, n)</span></span>;

<span class="hljs-comment">// run f every n seconds</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_every</span><span class="hljs-params">(f, n)</span></span>;

<span class="hljs-comment">// run every day at hour:min:sec</span>
<span class="hljs-comment">// @hour: 0-23, default is 0</span>
<span class="hljs-comment">// @min:  0-59, default is 0</span>
<span class="hljs-comment">// @sec:  0-59, default is 0</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run_daily</span><span class="hljs-params">(f, hour=<span class="hljs-number">0</span>, min=<span class="hljs-number">0</span>, sec=<span class="hljs-number">0</span>)</span></span>;
</div></code></pre>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>TaskSched s;                      <span class="hljs-comment">// start task scheduling thread</span>
s.run_in(f, <span class="hljs-number">3</span>);                   <span class="hljs-comment">// run f once after 3 seconds    void f();</span>
s.run_every(<span class="hljs-built_in">std</span>::bind(f, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>);  <span class="hljs-comment">// run f every 3 seconds         void f(int);</span>
s.run_daily(f);                   <span class="hljs-comment">// run f every day at 00:00:00</span>
s.run_daily(f, <span class="hljs-number">23</span>);               <span class="hljs-comment">// run f every day at 23:00:00</span>
s.run_daily(f, <span class="hljs-number">23</span>, <span class="hljs-number">30</span>);           <span class="hljs-comment">// run f every day at 23:30:00</span>
s.stop();                         <span class="hljs-comment">// stop the task scheduling thread</span>
</div></code></pre>
<h2 id="15-coroutine-library-co">15. Coroutine library (co)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/co.h">co/co.h</a>.</p>
<h3 id="151-basic-concepts">15.1 Basic Concepts</h3>
<ul>
<li>Coroutines are lightweight scheduling units that run in threads.</li>
<li>Coroutines are to threads, similar to threads to processes.</li>
<li>There can be multiple threads in a process and multiple coroutines in a thread.</li>
<li>The thread where the coroutine runs in is generally called the scheduling thread.</li>
<li>When a coroutine occurs such as io blocking or calling sleep, the scheduling thread will suspend the coroutine.</li>
<li>When a coroutine is suspended, the scheduling thread will switch to other coroutines waiting to be executed.</li>
<li>Switching of coroutines is performed in user mode, which is faster than switching between threads.</li>
</ul>
<p>Coroutines are very suitable for writing network programs, and can achieve synchronous programming without asynchronous callbacks, which greatly reduces the programmer's ideological burden.</p>
<p>The <code>co</code> library implements a <a href="https://github.com/golang/go/">golang</a> style coroutine with the following features:</p>
<ul>
<li>Built-in multiple scheduling threads, the default is number of the system CPU cores.</li>
<li>The coroutines in the same scheduling thread share a stack. When a coroutine is suspended, the data on the stack will be copied out, and the data will be copied onto the stack when it is switched back. This method greatly reduces the memory footprint and millions of coroutines can be easily created on a single machine.</li>
<li>There is a flat relationship between coroutines, and new coroutines can be created anywhere (including in coroutines).</li>
</ul>
<p>The co coroutine library is based on <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>, <a href="https://man.openbsd.org/kqueue.2">kqueue</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/io-completion-ports">iocp</a> implementation.</p>
<p>The relevant code for context switching in the co coroutine library is taken from <a href="https://github.com/tboox/tbox/">tbox</a> by <a href="https://github.com/waruqi">ruki</a>, and tbox refers to the implementation of <a href="https://www.boost.org/doc/libs/1_70_0/libs/context/doc/html/index.html">boost</a>, thanks here!</p>
<h3 id="152-create-coroutines-go">15.2 Create coroutines (go)</h3>
<p><code>Golang</code> uses the keyword <code>go</code> to create coroutines. Similarly, the co library provides the <code>go()</code> method to create coroutines.</p>
<p>Creating a coroutine is similar to creating a thread. You need to specify a coroutine function. The first parameter of the <code>go()</code> method is the coroutine function:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*f)())</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*f)(<span class="hljs-keyword">void</span>*), <span class="hljs-keyword">void</span>* p)</span></span>;  <span class="hljs-comment">// p specifies function parameters</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (T::*f)(), T* p)</span></span>;       <span class="hljs-comment">// p binds a class T object</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt;&amp; f)</span></span>;
</div></code></pre>
<p>Actual tests found that creating objects of type <code>std::function</code> is expensive, so go() is especially optimized for function types <code>void f()</code>,<code> void f(void *)</code>, <code>void T::f() </code>. In practical applications, these three types of functions should be used preferentially.</p>
<p>Strictly speaking, the go() method just allocates a <code>callback</code> to a scheduling thread. The actual creation of the coroutine is done by the scheduling thread. However, from the user's point of view, it can be logically considered that go() creates a coroutine and assigns it to a designated scheduling thread, waiting to be executed.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>go(f);                       <span class="hljs-comment">// void f();</span>
go(f, p);                    <span class="hljs-comment">// void f(void*);   void* p;</span>
go(&amp;T::f, p);                <span class="hljs-comment">// void T::f();     T* p;</span>
go(<span class="hljs-built_in">std</span>::bind(f, <span class="hljs-number">7</span>));         <span class="hljs-comment">// void f(int);</span>
go(<span class="hljs-built_in">std</span>::bind(&amp;T::f, p, <span class="hljs-number">7</span>));  <span class="hljs-comment">// void T::f(int);  T* p;</span>
</div></code></pre>
<h3 id="153-coroutine-api">15.3 coroutine api</h3>
<p>In addition to <code>go()</code>, the co-coroutine library also provides the following apis (located in namespace co):</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ms)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_sched_num</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sched_id</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coroutine_id</span><span class="hljs-params">()</span></span>;
</div></code></pre>
<ul>
<li>
<p>When <code>sleep</code> is called in a coroutine, the scheduling thread will suspend the coroutine and switch to other coroutines waiting to be executed.</p>
</li>
<li>
<p><code>stop</code> will quit all scheduling threads, usually called before the process exits.</p>
</li>
<li>
<p><code>max_sched_num</code> returns the maximum number of supported scheduling threads. This value is currently the number of system CPU cores.</p>
</li>
<li>
<p><code>sched_id</code> returns the id of the currently scheduled thread, or -1 if the current thread is not a scheduling thread. The value range of id is 0 to <code>max_sched_num-1</code>.</p>
</li>
<li>
<p><code>coroutine_id</code> returns the id of the current coroutine, or -1 if the current thread is not a coroutine. Coroutines in different scheduling threads may have the same id.</p>
</li>
<li>
<p>Code example</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// print the current sched_id and coroutine_id every 1 second</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        co::sleep(<span class="hljs-number">1000</span>);
        LOG &lt;&lt; <span class="hljs-string">"sid: "</span>&lt;&lt; co::sched_id() &lt;&lt;<span class="hljs-string">" cid: "</span>&lt;&lt; co::coroutine_id();
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{
    flag::init(argc, argv);
    <span class="hljs-built_in">log</span>::init();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">32</span>; ++i) go(f);

    sleep::sec(<span class="hljs-number">8</span>); <span class="hljs-comment">// prevent the main thread from exiting immediately</span>
    co::stop();    <span class="hljs-comment">// stop all scheduling threads</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="154-network-programming">15.4 Network Programming</h3>
<p>co wraps commonly used socket APIs to support general network programming. All these APIs are in the <code>namespace co</code>, which must generally be called in a coroutine. Unlike the native APIs, when IO is blocked or sleep is called for these APIs, the scheduling thread will suspend the current coroutine and switch to other coroutines waiting to be executed.</p>
<h4 id="1541-commonly-used-socket-apis">15.4.1 Commonly used socket APIs</h4>
<p>Co provides some commonly used socket APIs:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">sock_t</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> proto)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">sock_t</span> <span class="hljs-title">tcp_socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af=AF_INET)</span></span>; <span class="hljs-comment">// @af: address family, AF_INET, AF_INET6, etc</span>
<span class="hljs-function"><span class="hljs-keyword">sock_t</span> <span class="hljs-title">udp_socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af=AF_INET)</span></span>; <span class="hljs-comment">// @af: address family, AF_INET, AF_INET6, etc</span>

<span class="hljs-function">close shutdown bind listen accept getsockopt
recv recvfrom send sendto connect setsockopt

<span class="hljs-keyword">int</span> <span class="hljs-title">recvn</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd, <span class="hljs-keyword">void</span>* buf, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> ms=<span class="hljs-number">-1</span>)</span></span>;
</div></code></pre>
<p>Most of the APIs provided by co are consistent with the native socket APIs, and their usage is almost the same, but there are some slight differences. The instructions are as follows:</p>
<ul>
<li>
<p>The <code>struct sockaddr*</code> in the native api parameters has been replaced with <code>void*</code>, avoiding the trouble of manual conversion.</p>
</li>
<li>
<p><code>socket</code>, <code>tcp_socket</code>, <code>udp_socket</code> are used to create sockets, the created sockets are non-blocking on linux/mac platforms, and [overlapped](https://support.microsoft.com/en- us/help/181611/socket-overlapped-io-versus-blocking-nonblocking-mode) on Windows.</p>
</li>
<li>
<p><code>close</code> can take an additional parameter <code>@ms</code> (default is 0), suspend the current coroutine for several milliseconds, and then close the socket.</p>
</li>
<li>
<p><code>shutdown</code> uses a single character <code>@c</code> to specify the direction, <code>'r'</code> turns off reading, <code>'w'</code> turns off writing, and both reading and writing are turned off by default.</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd, <span class="hljs-keyword">char</span> c=<span class="hljs-string">'b'</span>)</span></span>;
</div></code></pre>
<ul>
<li>
<p>The socket returned by <code>accept</code> is non-blocking or overlapped, and does not need to be set by the user.</p>
</li>
<li>
<p><code>connect, recv, recvn, recvfrom, send, sendto</code> can take one more parameter specifying the timeout time <code>@ms</code> (default is -1). When a timeout occurs, these APIs return -1 and set errno to <code>ETIMEDOUT</code>.</p>
</li>
<li>
<p><code>recvn</code> receives <code>@n</code> bytes of tcp data, returns n after all received, 0 when disconnected, -1 for other errors.</p>
</li>
<li>
<p><strong>Note:</strong> accept, connect, recv, recvn, recvfrom, send and sendto must be called in coroutines.</p>
</li>
<li>
<p><strong>Special attention:</strong> <code>close</code> and <code>shutdown</code> will not block, but in order to complete the internal cleanup work normally, they must be called in the scheduling thread where the coroutine is located. Generally speaking, when performing recv and send operations in a coroutine, it is best to also call close and shutdown in this coroutine to close the socket.</p>
</li>
</ul>
<p>The above api returns -1 when an error occurs, you can use <code>co::error()</code> to get the error code, and <code>co::strerror()</code> to see the error description.</p>
<h4 id="1542-common-socket-option-settings">15.4.2 Common socket option settings</h4>
<p>co provides the following APIs for setting commonly used socket options:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_reuseaddr</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd)</span></span>;               <span class="hljs-comment">// Set SO_REUSEADDR</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_tcp_nodelay</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd)</span></span>;             <span class="hljs-comment">// Set TCP_NODELAY</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_tcp_keepalive</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd)</span></span>;           <span class="hljs-comment">// Set SO_KEEPALIVE</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_send_buffer_size</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd, <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">// Set the send buffer size</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_recv_buffer_size</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd, <span class="hljs-keyword">int</span> n)</span></span>; <span class="hljs-comment">// Set the receive buffer size</span>
</div></code></pre>
<h4 id="1543-other-apis">15.4.3 Other APIs</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// Fill in the ip address</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">init_ip_addr</span><span class="hljs-params">(struct sockaddr_in* addr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">init_ip_addr</span><span class="hljs-params">(struct sockaddr_in6* addr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port)</span></span>;

<span class="hljs-comment">// Convert ip address to string</span>
<span class="hljs-function">fastring <span class="hljs-title">ip_str</span><span class="hljs-params">(struct sockaddr_in* addr)</span></span>;
<span class="hljs-function">fastring <span class="hljs-title">ip_str</span><span class="hljs-params">(struct sockaddr_in6* addr)</span></span>;

<span class="hljs-comment">// Send a RST, abnormally close the tcp connection, </span>
<span class="hljs-comment">// avoid entering the timedwait state.</span>
<span class="hljs-comment">// @ms: The default is 0, suspending the coroutine </span>
<span class="hljs-comment">// for a few milliseconds before send RST.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset_tcp_socket</span><span class="hljs-params">(<span class="hljs-keyword">sock_t</span> fd, <span class="hljs-keyword">int</span> ms=<span class="hljs-number">0</span>)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">error</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// return the current error code</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">strerror</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// returns the current string error</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> err)</span></span>; <span class="hljs-comment">// returns the string corresponding to @err</span>
</div></code></pre>
<h4 id="1544-hook-system-api">15.4.4 hook system api</h4>
<p>Calling the socket api of the co library in coroutines will not block, but the native socket API called in some third-party libraries may still block. In order to solve this problem, it's necessary to hook related system APIs.</p>
<p>The co library currently supports hooks on the linux/mac platform. The following is a list of hook functions:</p>
<pre class="hljs"><code><div>sleep usleep nanosleep

accept accept4 connect close shutdown
read readv recv recvfrom recvmsg
write writev send sendto sendmsg
select poll gethostbyaddr gethostbyname

gethostbyaddr_r gethostbyname2   <span class="hljs-comment">// linux</span>
gethostbyname_r gethostbyname2_r <span class="hljs-comment">// linux</span>

epoll_wait <span class="hljs-comment">// linux</span>
kevent     <span class="hljs-comment">// mac</span>
</div></code></pre>
<p>Users generally don't need to care about api hooks. If you are interested, you can read the source code implementation of <a href="https://github.com/idealvin/co/tree/master/src/co/impl">hook</a>.</p>
<h4 id="1545-general-network-programming-mode-based-on-coroutines">15.4.5 General network programming mode based on coroutines</h4>
<p>Coroutines can achieve high-performance synchronous network programming. Taking the TCP program as an example, the server generally adopts a mode of one coroutine per connection, creating a new coroutine for each connection, and processing the data on the connection in the coroutine; the client does not need one connection per coroutine, connection pool is generally used instead, and multiple coroutines share the connections in the pool.</p>
<ul>
<li>The general mode of processing connection data on the server side:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">server_fun</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        co::recv(...); <span class="hljs-comment">// Receive client request data</span>
        process(...);  <span class="hljs-comment">// business processing</span>
        co::send(...); <span class="hljs-comment">// send the result to the client</span>
    }
    co::close(...);    <span class="hljs-comment">// close socket</span>
}
</div></code></pre>
<ul>
<li>The general mode for the client to handle connection data:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client_fun</span><span class="hljs-params">()</span> </span>{
    co::send(...); <span class="hljs-comment">// send request data to the server</span>
    co::recv(...); <span class="hljs-comment">// Receive server response data</span>
    process(...);  <span class="hljs-comment">// business processing</span>
}
</div></code></pre>
<h4 id="1546-example-of-tcp-serverclient-based-on-coroutine">15.4.6 Example of tcp server/client based on coroutine</h4>
<ul>
<li>server code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Connection</span> {</span>
    <span class="hljs-keyword">sock_t</span> fd;   <span class="hljs-comment">// conn fd</span>
    fastring ip; <span class="hljs-comment">// peer ip</span>
    <span class="hljs-keyword">int</span> port;    <span class="hljs-comment">// peer port</span>
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">on_new_connection</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Connection&gt; <span class="hljs-title">conn</span><span class="hljs-params">((Connection*)p)</span></span>;
    <span class="hljs-keyword">sock_t</span> fd = conn-&gt;fd;
    co::set_tcp_keepalive(fd);
    co::set_tcp_nodelay(fd);
    
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>] = {<span class="hljs-number">0</span> };

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">int</span> r = co::recv(fd, buf, <span class="hljs-number">4</span>);
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) {         <span class="hljs-comment">// The client closed the connection</span>
            co::close(fd);    <span class="hljs-comment">// Call close to close the connection normally</span>
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span>) { <span class="hljs-comment">// Abnormal error, directly reset the connection</span>
            co::reset_tcp_socket(fd, <span class="hljs-number">1024</span>);
            <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
            LOG &lt;&lt; <span class="hljs-string">"recv "</span>&lt;&lt; buf;
            LOG &lt;&lt; <span class="hljs-string">"send pong"</span>;
            co::send(fd, <span class="hljs-string">"pong"</span>, <span class="hljs-number">4</span>);
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">server_fun</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">sock_t</span> fd = co::tcp_socket();
    co::set_reuseaddr(fd);

    <span class="hljs-keyword">sock_t</span> connfd;
    <span class="hljs-keyword">int</span> addrlen = <span class="hljs-keyword">sizeof</span>(sockaddr_in);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span>
    co::init_ip_addr(&amp;addr, <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7788</span>);

    co::bind(fd, &amp;addr, <span class="hljs-keyword">sizeof</span>(addr));
    co::listen(fd, <span class="hljs-number">1024</span>);

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        connfd = co::accept(fd, &amp;addr, &amp;addrlen);
        <span class="hljs-keyword">if</span> (connfd == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;

        Connection* conn = <span class="hljs-keyword">new</span> Connection;
        conn-&gt;fd = connfd;
        conn-&gt;ip = co::ip_str(&amp;addr);
        conn-&gt;port = ntoh16(addr.sin_port);

        <span class="hljs-comment">// Create a new coroutine for each connection</span>
        co::go(on_new_connection, conn);
    }
}

go(server_fun); <span class="hljs-comment">// Start server coroutine</span>
</div></code></pre>
<ul>
<li>client code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client_fun</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">sock_t</span> fd = co::tcp_socket();

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span>
    co::init_ip_addr(&amp;addr, <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7788</span>);

    co::connect(fd, &amp;addr, <span class="hljs-keyword">sizeof</span>(addr), <span class="hljs-number">3000</span>);
    co::set_tcp_nodelay(fd);

    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">8</span>] = {<span class="hljs-number">0</span> };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">7</span>; ++i) {
        co::sleep(<span class="hljs-number">1000</span>);
        LOG &lt;&lt; <span class="hljs-string">"send ping"</span>;
        co::send(fd, <span class="hljs-string">"ping"</span>, <span class="hljs-number">4</span>);
        co::recv(fd, buf, <span class="hljs-number">4</span>);
        LOG &lt;&lt; <span class="hljs-string">"recv "</span>&lt;&lt; buf;
    }

    co::close(fd);
}

go(client_fun); <span class="hljs-comment">// Start client coroutine</span>
</div></code></pre>
<h3 id="155-coroutine-synchronization-mechanism">15.5 Coroutine synchronization mechanism</h3>
<p>The co library implements a synchronization mechanism similar to threads. Developers familiar with multithreaded programming can easily switch from threads to coroutine programming.</p>
<h4 id="1551-coroutine-lock-comutex">15.5.1 Coroutine lock (co::Mutex)</h4>
<p><code>co::Mutex</code> is similar to <code>Mutex</code> in the thread library, except that it needs to be used in coroutine environment. When the acquisition of the lock fails, the scheduling thread will suspend the current coroutine, and the scheduling thread itself will not block.</p>
<p>In addition, co also provides a <code>co::MutexGuard</code> class, which is used in the same way as <code>MutexGuard</code> in the thread library.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>co::Mutex mtx;
<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">co::MutexGuard <span class="hljs-title">g</span><span class="hljs-params">(mtx)</span></span>;
    ++v;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">co::MutexGuard <span class="hljs-title">g</span><span class="hljs-params">(mtx)</span></span>;
    --v;
}

go(f1);
go(f2);
</div></code></pre>
<h4 id="1552-coroutine-synchronization-event-coevent">15.5.2 Coroutine synchronization event (co::Event)</h4>
<p><code>co::Event</code> is similar to <code>SyncEvent</code> in the thread library, but it needs to be used in coroutine environment. When the <code>wait()</code> method is called, the scheduling thread will suspend the current coroutine, and the scheduling thread itself will not block.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>co::Event ev;
<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ev.wait(100); // wait for 100 ms</span>
    ev.wait();       <span class="hljs-comment">// wait forever</span>
    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">2</span>) v = <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>{
    v = <span class="hljs-number">2</span>;
    ev.signal();
}

go(f1);
go(f2);
</div></code></pre>
<h3 id="156-coroutine-pool">15.6 Coroutine Pool</h3>
<h4 id="1561-copool">15.6.1 co::Pool</h4>
<p>Threads supports the <code>TLS</code> mechanism, and coroutines can also support a similar <code>CLS</code> mechanism, but considering that millions of coroutines may be created, CLS does not seem to be very efficient. The co library eventually gave up CLS and implemented <code>co::Pool</code> instead:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> {</span>
  <span class="hljs-keyword">public</span>:
    Pool();
    Pool(<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>*()&gt;&amp;&amp; ccb, ​​<span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">void</span>*)&gt;&amp;&amp; dcb, 
         <span class="hljs-keyword">size_t</span> cap=(<span class="hljs-keyword">size_t</span>)<span class="hljs-number">-1</span>);

    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span></span>;

  <span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">void</span>* _p;
};
</div></code></pre>
<ul>
<li>Constructor</li>
</ul>
<p>The parameters <code>ccb</code> and <code>dcb</code> in the second constructor can be used to create and destroy an element, and <code>cap</code> is used to specify the maximum capacity of the pool. The maximum capacity here is for a single thread. If cap is set to 1024 and there are 8 scheduling threads, the total maximum capacity is actually 8192. Also note that the maximum capacity is only valid when dcb is also specified.</p>
<ul>
<li>pop</li>
</ul>
<p>This method pulls an element from the pool. When the pool is empty, if ccb is set, call ccb to create an element and return; if ccb is not set, return NULL.</p>
<ul>
<li>push</li>
</ul>
<p>This method puts the element back into the pool. If the element is a NULL pointer, it is ignored. If the maximum capacity is exceeded and dcb is specified, call dcb directly to destroy the element without putting it into the pool.</p>
<p>The co::Pool class is coroutine safe. Calling the pop and push methods does not require locking, but it must be called in coroutines.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>co::Pool p;

<span class="hljs-keyword">void</span> f {
    Redis* rds = (Redis*) p.pop();    <span class="hljs-comment">// pull a redis connection from the pool</span>
    <span class="hljs-keyword">if</span> (rds == <span class="hljs-literal">NULL</span>) rds = <span class="hljs-keyword">new</span> Redis; <span class="hljs-comment">// create a new redis connection</span>

    rds-&gt;get(<span class="hljs-string">"xx"</span>); <span class="hljs-comment">// call the get method of redis</span>
    p.push(rds);    <span class="hljs-comment">// put it back</span>
}

go(f);
</div></code></pre>
<h4 id="1562-copoolguard">15.6.2 co::PoolGuard</h4>
<p><code>co::PoolGuard</code> is a template class that pulls an element from co::Pool during construction and puts it back when destructuring. In addition, it also overloads <code>operator-&gt;</code>, so that we can use it like a smart pointer.</p>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Specify ccb, ​​dcb for automatic creation and destruction of Redis</span>
<span class="hljs-function">co::Pool <span class="hljs-title">p</span><span class="hljs-params">(
    []() {<span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>*) <span class="hljs-keyword">new</span> Redis; }, <span class="hljs-comment">// Specify ccb</span>
    [](<span class="hljs-keyword">void</span>* p) {<span class="hljs-keyword">delete</span> (Redis*)p;}    <span class="hljs-comment">// Specify dcb</span>
)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">co::PoolGuard&lt;Redis&gt; <span class="hljs-title">rds</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// rds can be regarded as a Redis* pointer</span>
    rds-&gt;get(<span class="hljs-string">"xx"</span>);              <span class="hljs-comment">// call the get method of redis</span>
}

go(f);
</div></code></pre>
<p>With CLS mechanism, 100k coroutines needs to establish 100k connections. But using Pool, 100k coroutines may only need to share a small number of connections. Pool seems to be more efficient and reasonable than CLS, which is why this library does not support CLS.</p>
<h3 id="157-configuration-items">15.7 Configuration items</h3>
<p>The configuration items supported by the co library are as follows:</p>
<ul>
<li>
<p>co_sched_num</p>
<p>Number of scheduling threads. The default is the number of system CPU cores. In the current implementation, this value must be &lt;= the number of CPU cores.</p>
</li>
<li>
<p>co_stack_size</p>
<p>Coroutine stack size, default is 1MB. Each scheduling thread allocates a stack, and coroutines within the scheduling thread share this stack.</p>
</li>
<li>
<p>co_max_recv_size</p>
<p>The maximum data length that can be received at one time for <code>co::recv</code>. The default is 1M. If it exceeds this size, data will be received in multiple calls of <code>co::recv</code>.</p>
</li>
<li>
<p>co_max_send_size</p>
<p>The maximum data length that can be sent at one time for <code>co::send</code>. The default is 1M. If it exceeds this size, data will be sent in multiple calls of <code>co::send</code>.</p>
</li>
</ul>
<h2 id="16-efficient-json-library-json">16. Efficient json library (json)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/json.h">co/json.h</a>.</p>
<p>The <code>json</code> library is designed to be streamlined, efficient, and easy to use. It is comparable to <a href="https://github.com/Tencent/rapidjson">rapidjson</a> in performance. If you use <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>, the performance of <code>parse</code> and <code>stringify</code> will be further improved.</p>
<ul>
<li>Features of the json library
<ul>
<li>Supports 5 basic types: null, bool, int, double and string.</li>
<li>Supports two composite types, array and object.</li>
<li>All types are represented by a single Json class.</li>
<li>There is only one pointer data member in the Json class, <code>sizeof(Json) == sizeof(void*)</code>.</li>
<li>Json has a built-in reference count. The copy operation only increments the reference count (<strong>atomic operation, thread-safe</strong>), no memory copy is performed.</li>
<li>A built-in memory allocator (Jalloc) is used to optimize most memory allocation operations.</li>
</ul>
</li>
</ul>
<h3 id="161-basic-types">16.1 Basic types</h3>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div>Json x;                          <span class="hljs-comment">// null</span>
x.is_null();                     <span class="hljs-comment">// determine if it is null</span>

Json x = <span class="hljs-literal">false</span>;                  <span class="hljs-comment">// bool type</span>
x.is_bool();                     <span class="hljs-comment">// determine whether it is bool type</span>
<span class="hljs-keyword">bool</span> b = x.get_bool();           <span class="hljs-comment">// get value of bool type</span>

Json x = <span class="hljs-number">123</span>;                    <span class="hljs-comment">// int type</span>
<span class="hljs-keyword">int</span> i = x.get_int();             <span class="hljs-comment">// get value of int type</span>

Json x = (int64) <span class="hljs-number">23</span>;             <span class="hljs-comment">// int type, 64-bit</span>
int64 i = x.get_int64();         <span class="hljs-comment">// returns a 64-bit integer</span>

Json x = <span class="hljs-number">3.14</span>;                   <span class="hljs-comment">// double type</span>
<span class="hljs-keyword">double</span> d = x.get_double();       <span class="hljs-comment">// get value of double type</span>

Json x = <span class="hljs-string">"hello world"</span>;          <span class="hljs-comment">// string type</span>
<span class="hljs-function">Json <span class="hljs-title">x</span><span class="hljs-params">(s, n)</span></span>;                    <span class="hljs-comment">// string type (const char* s, size_t n)</span>
x.is_string();                   <span class="hljs-comment">// determine if it is a string type</span>
x.size();                        <span class="hljs-comment">// returns the length of the string</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s = x.get_string();  <span class="hljs-comment">// returns pointer to a null-terminated string</span>
</div></code></pre>
<h3 id="162-array-type">16.2 Array type</h3>
<p><code>array</code> is an array type that can store any type of Json object.</p>
<pre class="hljs"><code><div>Json x = json::<span class="hljs-built_in">array</span>();      <span class="hljs-comment">// create an empty array, different from null</span>
x.is_array();                <span class="hljs-comment">// determine if it is an array</span>
x.size();                    <span class="hljs-comment">// returns the number of elements in the array</span>
x.empty();                   <span class="hljs-comment">// determine if the array is empty</span>

Json x;                      <span class="hljs-comment">// null, becomes array type after push_back is called</span>
x.push_back(<span class="hljs-literal">false</span>);          <span class="hljs-comment">// add a value of type bool</span>
x.push_back(<span class="hljs-number">1</span>);              <span class="hljs-comment">// add a value of type int</span>
x.push_back(<span class="hljs-number">3.14</span>);           <span class="hljs-comment">// add a value of type double</span>
x.push_back(<span class="hljs-string">"hello"</span>);        <span class="hljs-comment">// add a value of type string</span>
x.push_back(x);              <span class="hljs-comment">// add a value of type array</span>
x.push_back(obj);            <span class="hljs-comment">// add a value of type object</span>

<span class="hljs-comment">// access members of array</span>
x[<span class="hljs-number">0</span>].get_bool();
x[<span class="hljs-number">1</span>].get_int();

<span class="hljs-comment">// traverse the array</span>
<span class="hljs-keyword">for</span> (uint32 i = <span class="hljs-number">0</span>; i &lt; x.size(); ++i) {
    Json&amp; v = x[i];
}
</div></code></pre>
<h3 id="163-object-type">16.3 Object type</h3>
<p>The <code>object</code> type is stored internally in the form of key-value. The value can be any type of Json object. The key has the following restrictions:</p>
<ul>
<li>key must be a C-style string ending in <code>'\0'</code>.</li>
<li>The key cannot contain double quotes <code>&quot;</code>.</li>
</ul>
<pre class="hljs"><code><div>Json x = json::object();       <span class="hljs-comment">// create an empty object, different from null</span>
x.is_object();                 <span class="hljs-comment">// determine if it is object type</span>
x.size();                      <span class="hljs-comment">// returns the number of elements in object</span>
x.empty();                     <span class="hljs-comment">// determine if object is empty</span>

Json x;                        <span class="hljs-comment">// null, becomes object after calling add_member()</span>
x.add_member(<span class="hljs-string">"name"</span>, <span class="hljs-string">"Bob"</span>);   <span class="hljs-comment">// add string</span>
x.add_member(<span class="hljs-string">"age"</span>, <span class="hljs-number">23</span>);       <span class="hljs-comment">// add int</span>
x.add_member(<span class="hljs-string">"height"</span>, <span class="hljs-number">1.68</span>);  <span class="hljs-comment">// add double</span>
x.add_member(<span class="hljs-string">"array"</span>, <span class="hljs-built_in">array</span>);  <span class="hljs-comment">// add array</span>
x.add_member(<span class="hljs-string">"obj"</span>, obj);      <span class="hljs-comment">// add object</span>

x.has_member(<span class="hljs-string">"name"</span>);          <span class="hljs-comment">// determine if the member exists</span>
x[<span class="hljs-string">"name"</span>].get_string();        <span class="hljs-comment">// get value of the member</span>

<span class="hljs-comment">// return null if the key does not exist</span>
Json v = x.find(<span class="hljs-string">"age"</span>);
<span class="hljs-keyword">if</span> (v.is_int()) v.get_int();

<span class="hljs-keyword">if</span> (!(v = x.find(<span class="hljs-string">"obj"</span>)).is_null()) {
    do_something();
}

<span class="hljs-comment">// traverse the object</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = x.begin(); it != x.end(); ++it) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* key = it-&gt;key;  <span class="hljs-comment">// key</span>
    Json&amp; v = it-&gt;value;        <span class="hljs-comment">// value</span>
}
</div></code></pre>
<h3 id="164-json-to-string">16.4 Json to string</h3>
<p>The Json class provides <code>str()</code> and <code>pretty()</code> methods to convert a Json object into a string:</p>
<pre class="hljs"><code><div>Json x;
fastring s = x.str();     <span class="hljs-comment">// returns a string</span>
fastring s = x.pretty();  <span class="hljs-comment">// returns a pretty string</span>

fastream fs;
fs &lt;&lt; x;   <span class="hljs-comment">// write json string to fastream</span>
LOG &lt;&lt; x;  <span class="hljs-comment">// write json string to log file</span>
</div></code></pre>
<p>In addition, the Json class also provides a <code>dbg()</code> method to convert Json into a debug string. The long strings inside Json object may be truncated:</p>
<pre class="hljs"><code><div>Json x;
fastring s = x.dbg();
LOG &lt;&lt; x; <span class="hljs-comment">// Actually equivalent to LOG &lt;&lt; x.dbg();</span>
</div></code></pre>
<h3 id="165-string-to-json">16.5 String to json</h3>
<p><code>json::parse()</code> or the <code>parse_from()</code> method in the Json class can convert a string into a Json object:</p>
<pre class="hljs"><code><div>Json x;
fastring s = x.str();

<span class="hljs-comment">// When parse fails, y is null</span>
Json y = json::parse(s);
Json y = json::parse(s.data(), s.size());
y.parse_from(x.str());
</div></code></pre>
<h3 id="166-notes">16.6 Notes</h3>
<h4 id="1661-adding-and-finding-members">16.6.1 Adding and finding members</h4>
<p>For the <code>object</code> type, an internal array is used to store the key-value pairs. This keeps the order in which members are added, but at the same time increases the cost of finding members. <code>operator[]</code> may be slow as it requires to find the member first.</p>
<ul>
<li>
<p>Use <code>add_member</code> instead of <code>operator[]</code> when adding members</p>
<pre class="hljs"><code><div><span class="hljs-comment">// add members directly to the end without member searching.</span>
x.add_member(<span class="hljs-string">"age"</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">// more efficient than x["age"] = 23</span>
</div></code></pre>
</li>
<li>
<p>Replace <code>operator[]</code> with <code>find</code> when finding members</p>
<pre class="hljs"><code><div><span class="hljs-comment">// not so efficient member access with 3 search operations.</span>
<span class="hljs-keyword">if</span> (x.has_member(<span class="hljs-string">"age"</span>) &amp;&amp; x[<span class="hljs-string">"age"</span>].is_int()) {
    <span class="hljs-keyword">int</span> i = x[<span class="hljs-string">"age"</span>].get_int();
}

<span class="hljs-comment">// using find() instead of operator[], need only a single search operation.</span>
Json v = x.find(<span class="hljs-string">"age"</span>);
<span class="hljs-keyword">if</span> (v.is_int()) {
    <span class="hljs-keyword">int</span> i = v.get_int();
}
</div></code></pre>
</li>
</ul>
<h4 id="1662-special-characters-in-string-types">16.6.2 Special characters in string types</h4>
<p>The json string internally ends with '\0' and mustn't contain any binary character.</p>
<p>The json string supports escape characters such as <code>&quot;</code> and <code>\</code>, as well as <code>\r, \n, \t</code>. However, containing these special characters will reduce the performance of <code>json::parse()</code>.</p>
<pre class="hljs"><code><div>Json x = <span class="hljs-string">"hello \r \n \t"</span>;  <span class="hljs-comment">// ok, the string contains escape characters</span>
Json x = <span class="hljs-string">"hello \" world"</span>;  <span class="hljs-comment">// ok, the string contains "</span>
Json x = <span class="hljs-string">"hello \\ world"</span>;  <span class="hljs-comment">// ok, the string contains \ </span>
</div></code></pre>
<h2 id="17-high-performance-json-rpc-framework-rpc">17. High-performance json rpc framework (rpc)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/rpc.h">co/rpc.h</a>.</p>
<p>The <code>rpc</code> framework is implemented based on coroutines and internally uses <code>tcp/json</code> as the transmission protocol. Simple tests show that single-threaded qps can reach <code>120k+</code>. Compared with struct-based binary protocols, json has at least the following advantages:</p>
<ul>
<li>It's easy to capture the package to see the transmitted json object, which is convenient for debugging.</li>
<li>The rpc call directly transmits the json object without defining various structures, which greatly reduces the amount of codes.</li>
<li>The rpc call parameters have the same form, fixed to <code>(const Json&amp; req, Json&amp; res)</code>, it is easy to generate code automatically.</li>
<li>A general rpc client can be implemented, no need to generate different client codes for different rpc server.</li>
</ul>
<h3 id="171-introduction-to-rpc-server-interface">17.1 Introduction to rpc server interface</h3>
<p>The interface of the rpc server is very simple:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">namespace</span> rpc {
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span> {</span>
  <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Service() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// business processing</span>
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> {</span>
  <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Server() = <span class="hljs-keyword">default</span>;

    <span class="hljs-comment">// start rpc server coroutine</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;               

    <span class="hljs-comment">// Service must be added before start()</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_service</span><span class="hljs-params">(Service*)</span> </span>= <span class="hljs-number">0</span>; 
};

<span class="hljs-comment">// Create an rpc server, if passwd is not empty, authentication is </span>
<span class="hljs-comment">// required for every new client connection.</span>
<span class="hljs-function">Server* <span class="hljs-title">new_server</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* passwd=<span class="hljs-string">""</span>)</span></span>;
} <span class="hljs-comment">// rpc</span>
</div></code></pre>
<p><code>rpc::Server</code> receives client connections, creates a new coroutine for each connection, the new coroutine receives client requests, and then synchronously calls the <code>process()</code> method provided by <code>rpc::Service</code> to process the request, and finally send the results back to the client.</p>
<p>For specific business processing, you need to inherit <code>rpc::Service</code> and implement the <code>process()</code> method. In fact, the code of <code>process()</code> is automatically generated, and users only need to implement the specific rpc calling method.</p>
<h3 id="172-implementing-an-rpc-server">17.2 Implementing an rpc server</h3>
<h4 id="1721-define-proto-files">17.2.1 Define proto files</h4>
<p>Here is a simple proto file <code>hello_world.proto</code>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// # or // for comments</span>
package xx <span class="hljs-comment">// namespace xx</span>

service HelloWorld {
    hello,
    world,
}

hello.req {
    <span class="hljs-string">"method"</span>: <span class="hljs-string">"hello"</span>
}

hello.res {
    <span class="hljs-string">"method"</span>: <span class="hljs-string">"hello"</span>,
    <span class="hljs-string">"err"</span>: <span class="hljs-number">200</span>,
    <span class="hljs-string">"errmsg"</span>: <span class="hljs-string">"200 ok"</span>
}

world.req {
    <span class="hljs-string">"method"</span>: <span class="hljs-string">"world"</span>
}

world.res {
    <span class="hljs-string">"method"</span>: <span class="hljs-string">"world"</span>,
    <span class="hljs-string">"err"</span>: <span class="hljs-number">200</span>,
    <span class="hljs-string">"errmsg"</span>: <span class="hljs-string">"200 ok"</span>
}
</div></code></pre>
<p><code>package xx</code> means to generate code into the namespace <code>xx</code>. You can also use <code>package xx.yy.zz</code> to generate nested namespaces.</p>
<p><code>service HelloWorld</code> defines a service class that extends <code>rpc::Service</code>. <code>Hello, world</code> are two rpc methods it provides.</p>
<p><code>hello.req, hello.res, world.req, world.res</code> are examples of request parameters and response results, which are not needed for generating code.</p>
<ul>
<li>Note that only one service can be defined in a proto file.</li>
</ul>
<h4 id="1722-generate-service-code">17.2.2 Generate service code</h4>
<p>See <a href="https://github.com/idealvin/co/tree/master/gen">co/gen</a> for the code generator.</p>
<ul>
<li>
<p>Generate gen</p>
<pre class="hljs"><code><div>xmake -b gen   <span class="hljs-comment"># run this command in the co root directory to build gen</span>
</div></code></pre>
</li>
<li>
<p>Generate service code</p>
<pre class="hljs"><code><div>gen hello_world.proto
</div></code></pre>
</li>
</ul>
<p>Here is the generated C++ header <code>hello_world.h</code>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/rpc.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"co/hash.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>

<span class="hljs-keyword">namespace</span> xx {

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span>:</span> <span class="hljs-keyword">public</span> rpc::Service {
  <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(HelloWorld::*Fun)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp;, Json&amp;)</span></span>;

    HelloWorld() {
        _methods[hash64(<span class="hljs-string">"ping"</span>)] = &amp;HelloWorld::ping;
        _methods[hash64(<span class="hljs-string">"hello"</span>)] = &amp;HelloWorld::hello;
        _methods[hash64(<span class="hljs-string">"world"</span>)] = &amp;HelloWorld::world;
    }

    <span class="hljs-keyword">virtual</span> ~HelloWorld() {}

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>{
        Json&amp; method = req[<span class="hljs-string">"method"</span>];
        <span class="hljs-keyword">if</span> (!method.is_string()) {
            res.add_member(<span class="hljs-string">"err"</span>, <span class="hljs-number">400</span>);
            res.add_member(<span class="hljs-string">"errmsg"</span>, <span class="hljs-string">"400 req has no method"</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">auto</span> it = _methods.find(hash64(method.get_string(), method.size()));
        <span class="hljs-keyword">if</span> (it == _methods.end()) {
            res.add_member(<span class="hljs-string">"err"</span>, <span class="hljs-number">404</span>);
            res.add_member(<span class="hljs-string">"errmsg"</span>, <span class="hljs-string">"404 method not found"</span>);
            <span class="hljs-keyword">return</span>;
        }

        (<span class="hljs-keyword">this</span>-&gt;*it-&gt;second)(req, res);
    }

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>{
        res.add_member(<span class="hljs-string">"method"</span>, <span class="hljs-string">"ping"</span>);
        res.add_member(<span class="hljs-string">"err"</span>, <span class="hljs-number">200</span>);
        res.add_member(<span class="hljs-string">"errmsg"</span>, <span class="hljs-string">"pong"</span>);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>= <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">world</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;uint64, Fun&gt; _methods;
};

} <span class="hljs-comment">// xx</span>
</div></code></pre>
<p>You can see that <code>HelloWrold</code>'s constructor has registered the hello, world method to the internal map, and the <code>process()</code> method finds and calls the corresponding rpc method according to the <code>method</code> field in rpc request. Users only need to extend the <code>HelloWorld</code> class and implement the hello, world methods for specific business processing. Keep in mind that these methods may be called in different threads, and pay attention to thread safety in the implementations.</p>
<p>If you need to connect to other network services internally in the business process method, you may use coroutine-safe <code>co::Pool</code> to manage network connections.</p>
<p>The generated header file can be directly placed where the server code is located, as the client does not need it at all. The client only refers to the req/res definition in the proto file, which is enough for constructing req to make rpc calls.</p>
<h4 id="1723-specific-business-implementation">17.2.3 Specific business implementation</h4>
<p>The following example code <code>hello_world.cc</code> gives a simple implementation:</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"hello_world.h"</span></span>

<span class="hljs-keyword">namespace</span> xx {

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span>:</span> <span class="hljs-keyword">public</span> HelloWorld {
  <span class="hljs-keyword">public</span>:
    HelloWorldImpl() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">virtual</span> ~HelloWorldImpl() = <span class="hljs-keyword">default</span>;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>{
        res.add_member(<span class="hljs-string">"method"</span>, <span class="hljs-string">"hello"</span>);
        res.add_member(<span class="hljs-string">"err"</span>, <span class="hljs-number">200</span>);
        res.add_member(<span class="hljs-string">"errmsg"</span>, <span class="hljs-string">"200 ok"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">world</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>{
        res.add_member(<span class="hljs-string">"method"</span>, <span class="hljs-string">"world"</span>);
        res.add_member(<span class="hljs-string">"err"</span>, <span class="hljs-number">200</span>);
        res.add_member(<span class="hljs-string">"errmsg"</span>, <span class="hljs-string">"200 ok"</span>);
    }
};

} <span class="hljs-comment">// xx</span>
</div></code></pre>
<h4 id="1724-start-the-rpc-server">17.2.4 Start the rpc server</h4>
<p>Generally, only three lines of code are needed to start the rpc server:</p>
<pre class="hljs"><code><div>rpc::Server* server = rpc::new_server(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7788</span>, <span class="hljs-string">"passwd"</span>);
server-&gt;add_service(<span class="hljs-keyword">new</span> xx::HelloWorldImpl);
server-&gt;start();
</div></code></pre>
<p>Note that calling the <code>start()</code> method will create a coroutine, and the server runs in the coroutine. Preventing the main thread from exiting is something the user needs to care about.</p>
<h3 id="173-rpc-client">17.3 rpc client</h3>
<p>The interface of the rpc client is as follows:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {</span>
  <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Client() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ping</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// send a heartbeat</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Json&amp; req, Json&amp; res)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-function">Client* <span class="hljs-title">new_client</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* passwd=<span class="hljs-string">""</span>)</span></span>;
} <span class="hljs-comment">// rpc</span>
</div></code></pre>
<p><code>rpc::new_client()</code> creates an rpc client. If the server has set a password, the client needs to bring the password for authentication.</p>
<p>The <code>call()</code> method initiates an rpc call. Different rpc requests can be identified with the method field in req.</p>
<p>The <code>ping()</code> method is for sending heartbeats to the server.</p>
<ul>
<li>Notes
<ul>
<li>When <code>rpc::Client</code> was created, the connection was not established immediately. Instead, the connection was established when the first rpc call was made.</li>
<li><code>delete rpc::Client</code> will close the connection. This operation must be performed within the coroutine.</li>
</ul>
</li>
</ul>
<p>Here is a simple rpc client example:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client_fun</span><span class="hljs-params">()</span> </span>{
    rpc::Client* c = rpc::new_client(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7788</span>, <span class="hljs-string">"passwd"</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
        Json req, res;
        req.add_member(<span class="hljs-string">"method"</span>, <span class="hljs-string">"hello"</span>);
        c-&gt;call(req, res); <span class="hljs-comment">// call the hello method</span>
    }

    <span class="hljs-keyword">delete</span> c; <span class="hljs-comment">// delete in the coroutine to close the connection safely</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{
    go(client_fun); <span class="hljs-comment">// create coroutine</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) sleep::sec(<span class="hljs-number">7</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Note that one <code>rpc::Client</code> corresponds to one connection. Do not use the same rpc::Client in multiple threads. In a multi-threaded environment, you can use <code>co::Pool</code> to manage client connections. Here is an example:</p>
<pre class="hljs"><code><div>co::Pool cli_pool;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">client_fun</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">co::Kakalot&lt;rpc::Client&gt; <span class="hljs-title">c</span><span class="hljs-params">(cli_pool)</span></span>;
    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">NULL</span>) c = rpc::new_client(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7788</span>, <span class="hljs-string">"passwd"</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) {
        Json req, res;
        req.add_member(<span class="hljs-string">"method"</span>, <span class="hljs-string">"hello"</span>);
        c-&gt;call(req, res); <span class="hljs-comment">// call the hello method</span>
    }
}

<span class="hljs-comment">// create 8 coroutines</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++ i) {
    go(client_fun);
}
</div></code></pre>
<h3 id="174-configuration-items">17.4 Configuration Items</h3>
<p>The rpc library supports the following configuration items:</p>
<ul>
<li>
<p>rpc_max_msg_size</p>
<p>The maximum length of the rpc message. The default is <code>8M</code>.</p>
</li>
<li>
<p>rpc_recv_timeout</p>
<p>rpc timeout time for receiving data, unit is millisecond, default is <code>1024</code> milliseconds.</p>
</li>
<li>
<p>rpc_send_timeout</p>
<p>rpc timeout time for sending data, unit is millisecond, default is <code>1024</code> milliseconds.</p>
</li>
<li>
<p>rpc_conn_timeout</p>
<p>rpc connection timeout time in milliseconds. The default is <code>3000</code> milliseconds.</p>
</li>
<li>
<p>rpc_conn_idle_sec</p>
<p>The time during which rpc keeps idle connections in seconds. The default is <code>180</code> seconds. If a connection does not receive any data after this time, the server may close the connection.</p>
</li>
<li>
<p>rpc_max_idle_conn</p>
<p>The maximum number of idle connections. The default is <code>128</code>. If the number of connections exceeds this value, the server will close some idle connections (connections that have not received data within rpc_conn_idle_sec time).</p>
</li>
<li>
<p>rpc_log</p>
<p>Whether to enable rpc logs. The default is <code>true</code>.</p>
</li>
</ul>
<h2 id="18-hash-library">18. Hash library</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/hash.h">co/hash.h</a>.</p>
<p>The <code>hash</code> library provides the following functions:</p>
<ul>
<li>
<p>hash64</p>
<p>Calculates a 64-bit hash value. The murmur 2 hash algorithm is used internally.</p>
</li>
<li>
<p>hash32</p>
<p>Calculates a 32-bit hash value. The murmur 2 hash algorithm is used internally on 32 bit platform. For 64 bit platform, return the lower 32 bits of <code>hash64</code> directly.</p>
</li>
<li>
<p>md5sum</p>
<p>Calculates the md5 value of a string or a specified length of data and returns a 32-byte string.</p>
</li>
<li>
<p>crc16</p>
<p>Calculate the crc16 value of a string or a specified length of data, the implementation is taken from <a href="https://github.com/antirez/redis/">redis</a>.</p>
</li>
<li>
<p>base64_encode</p>
<p>Base64 encoding, <code>\r, \n</code> are not added, it is not necessary in practical.</p>
</li>
<li>
<p>base64_decode</p>
<p>Base64 decoding, throws <code>const char*</code> type exception when decoding fails.</p>
</li>
<li>
<p>Code example</p>
<pre class="hljs"><code><div>uint64 h = hash64(s);                <span class="hljs-comment">// hash of string s</span>
uint64 h = hash64(s, n);             <span class="hljs-comment">// hash of the specified length of data</span>
uint32 h = hash32(s);                <span class="hljs-comment">// 32-bit hash of string s</span>

fastring s = md5sum(<span class="hljs-string">"hello world"</span>);  <span class="hljs-comment">// md5 of string, the result is 32 bytes</span>
uint16 x = crc16(<span class="hljs-string">"hello world"</span>);     <span class="hljs-comment">// crc16 of string</span>

fastring e = base64_encode(s);       <span class="hljs-comment">// base64 encoding</span>
fastring d = base64_decode(e);       <span class="hljs-comment">// base64 decoding</span>
</div></code></pre>
</li>
</ul>
<h2 id="19-path-library">19. Path library</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/path.h">co/path.h</a>.</p>
<p>The <code>path</code> library is ported from <a href="https://github.com/golang/go/blob/master/src/path/path.go">golang</a>. The path separator is assumed to be '/'.</p>
<ul>
<li>
<p><code>path::clean()</code></p>
<p>Returns the shortest equivalent form of a path. Continuous separators in the path are removed.</p>
<pre class="hljs"><code><div>path::clean(<span class="hljs-string">"./x//y/"</span>);    <span class="hljs-comment">// return "x/y"</span>
path::clean(<span class="hljs-string">"./x/.."</span>);     <span class="hljs-comment">// return "."</span>
path::clean(<span class="hljs-string">"./x/../.."</span>);  <span class="hljs-comment">// return ".."</span>
</div></code></pre>
</li>
<li>
<p><code>path::join()</code></p>
<p>Splices any number of strings into a complete path, the result was processed by path::clean().</p>
<pre class="hljs"><code><div>path::join(<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>, <span class="hljs-string">"z"</span>);  <span class="hljs-comment">// return "x/y/z"</span>
path::join(<span class="hljs-string">"/x/"</span>, <span class="hljs-string">"y"</span>);     <span class="hljs-comment">// return "/x/y"</span>
</div></code></pre>
</li>
<li>
<p><code>path::split()</code></p>
<p>Divide the path into two parts, dir and file. If the path does not contain a separator, the dir part is empty. The returned result satisfies the property <code>path = dir + file</code>.</p>
<pre class="hljs"><code><div>path::split(<span class="hljs-string">"/"</span>);     <span class="hljs-comment">//-&gt; {"/", ""}</span>
path::split(<span class="hljs-string">"/a"</span>);    <span class="hljs-comment">//-&gt; {"/", "a"}</span>
path::split(<span class="hljs-string">"/a/b"</span>);  <span class="hljs-comment">//-&gt; {"/a/", "b"}</span>
</div></code></pre>
</li>
<li>
<p><code>path::dir()</code></p>
<p>Returns the directory portion of the path, the result was processed by path::clean().</p>
<pre class="hljs"><code><div>path::dir(<span class="hljs-string">"a"</span>);   <span class="hljs-comment">// return "."</span>
path::dir(<span class="hljs-string">"a/"</span>);  <span class="hljs-comment">// return "a"</span>
path::dir(<span class="hljs-string">"/"</span>);   <span class="hljs-comment">// return "/"</span>
path::dir(<span class="hljs-string">"/a"</span>);  <span class="hljs-comment">// return "/";</span>
</div></code></pre>
</li>
<li>
<p><code>path::base()</code></p>
<p>Returns the last element of the path.</p>
<pre class="hljs"><code><div>path::base(<span class="hljs-string">""</span>);      <span class="hljs-comment">// return "."</span>
path::base(<span class="hljs-string">"/"</span>);     <span class="hljs-comment">// return "/"</span>
path::base(<span class="hljs-string">"/a/"</span>);   <span class="hljs-comment">// return "a", ignores the trailing delimiter</span>
path::base(<span class="hljs-string">"/a"</span>);    <span class="hljs-comment">// return "a"</span>
path::base(<span class="hljs-string">"/a/b"</span>);  <span class="hljs-comment">// return "b"</span>
</div></code></pre>
</li>
<li>
<p><code>path::ext()</code></p>
<p>This function returns the extension of the file name in the path.</p>
<pre class="hljs"><code><div>path::ext(<span class="hljs-string">"/a.cc"</span>);   <span class="hljs-comment">// return ".cc"</span>
path::ext(<span class="hljs-string">"/a.cc/"</span>);  <span class="hljs-comment">// return ""</span>
</div></code></pre>
</li>
</ul>
<h2 id="20-file-system-operations-fs">20. File System Operations (fs)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/fs.h">co/fs.h</a>.</p>
<p>The <code>fs</code> library minimally implements common file system operations. The path separator for different platforms is recommended to use <code>'/'</code> uniformly.</p>
<h3 id="201-metadata-operations">20.1 Metadata Operations</h3>
<ul>
<li>Code example</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span> x = fs::exists(path);  <span class="hljs-comment">// determine if the file exists</span>
<span class="hljs-keyword">bool</span> x = fs::isdir(path);   <span class="hljs-comment">// determine if the file is a directory</span>
int64 x = fs::mtime(path);  <span class="hljs-comment">// get the modification time of the file</span>
int64 x = fs::fsize(path);  <span class="hljs-comment">// get the size of the file</span>

fs::mkdir(<span class="hljs-string">"a/b"</span>);           <span class="hljs-comment">// mkdir a/b</span>
fs::mkdir(<span class="hljs-string">"a/b"</span>, <span class="hljs-literal">true</span>);     <span class="hljs-comment">// mkdir -p a/b</span>

fs::remove(<span class="hljs-string">"x/x.txt"</span>);      <span class="hljs-comment">// rm x/x.txt</span>
fs::remove(<span class="hljs-string">"a/b"</span>);          <span class="hljs-comment">// rmdir a/b, delete empty directory</span>
fs::remove(<span class="hljs-string">"a/b"</span>, <span class="hljs-literal">true</span>);    <span class="hljs-comment">// rm -rf a/b</span>

fs::rename(<span class="hljs-string">"a/b"</span>, <span class="hljs-string">"a/c"</span>);   <span class="hljs-comment">// rename</span>
fs::symlink(<span class="hljs-string">"/usr"</span>, <span class="hljs-string">"x"</span>);   <span class="hljs-comment">// soft link: x -&gt; /usr</span>
</div></code></pre>
<h3 id="202-basic-file-read-and-write-operations">20.2 Basic file read and write operations</h3>
<p>The <code>fs</code> library implements the <code>fs::file</code> class, which supports basic read and write operations on files.</p>
<ul>
<li>
<p>Features of <code>fs::file</code></p>
<ul>
<li>Support <code>r, w, a, m</code> four read and write modes, the first three are consistent with fopen, <code>m</code> is similar to <code>w</code>, but the data of existing files is not cleared.</li>
<li>Does not support caching, read and write files directly.</li>
<li>Support <code>move</code> semantics, you can put the file object directly into the STL container.</li>
</ul>
</li>
<li>
<p>Code example</p>
</li>
</ul>
<pre class="hljs"><code><div>fs::file f;               <span class="hljs-comment">// f.open() can be called later to open the file</span>
<span class="hljs-function">fs::file <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-string">"xx"</span>, <span class="hljs-string">'r'</span>)</span></span>;    <span class="hljs-comment">// Open the file in read mode</span>

<span class="hljs-comment">// automatically close the previously opened file</span>
f.open(<span class="hljs-string">"xx"</span>, <span class="hljs-string">'a'</span>);        <span class="hljs-comment">// append write, create if file does not exist</span>
f.open(<span class="hljs-string">"xx"</span>, <span class="hljs-string">'w'</span>);        <span class="hljs-comment">// normal write, create if file does not exist, </span>
                          <span class="hljs-comment">// and clear the data if the file exists.</span>
f.open(<span class="hljs-string">"xx"</span>, <span class="hljs-string">'m'</span>);        <span class="hljs-comment">// modify write, create if file does not exist, </span>
                          <span class="hljs-comment">// won't clear the data if the file exists.</span>

<span class="hljs-keyword">if</span> (f) f.read(buf, <span class="hljs-number">512</span>);  <span class="hljs-comment">// read up to 512 bytes</span>
f.write(buf, <span class="hljs-number">32</span>);         <span class="hljs-comment">// write 32 bytes</span>
f.write(<span class="hljs-string">"hello"</span>);         <span class="hljs-comment">// write string</span>
f.write(<span class="hljs-string">'c'</span>);             <span class="hljs-comment">// write a single character</span>
f.close();                <span class="hljs-comment">// close the file, it will be called in destructor. </span>
</div></code></pre>
<h3 id="203-file-stream-fsfstream">20.3 File stream (fs::fstream)</h3>
<p><code>fs::file</code> does not support caching, and the performance of writing small files is poor. For this reason, the <code>fs</code> library also provides the <code>fs::fstream</code> class.</p>
<ul>
<li>
<p>Features of <code>fs::fstream</code></p>
<ul>
<li>For write only, and supports two modes: <code>w, a</code>.</li>
<li>You can customize the cache size. The default is <code>8k</code>.</li>
<li>Supports <code>move</code> semantics, allowing fstream objects to be placed in STL containers.</li>
</ul>
</li>
<li>
<p>Code example</p>
</li>
</ul>
<pre class="hljs"><code><div>fs::fstream s;                     <span class="hljs-comment">// default cache is 8k</span>
<span class="hljs-function">fs::fstream <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">4096</span>)</span></span>;               <span class="hljs-comment">// Specify cache as 4k</span>
<span class="hljs-function">fs::fstream <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"path"</span>, <span class="hljs-string">'a'</span>)</span></span>;        <span class="hljs-comment">// append mode, cache defaults to 8k</span>
<span class="hljs-function">fs::fstream <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"path"</span>, <span class="hljs-string">'w'</span>, <span class="hljs-number">4096</span>)</span></span>;  <span class="hljs-comment">// write mode, specify 4k cache</span>

s.open(<span class="hljs-string">"path"</span>, <span class="hljs-string">'a'</span>);               <span class="hljs-comment">// Open and close the previously opened file</span>
<span class="hljs-keyword">if</span> (s) s &lt;&lt; <span class="hljs-string">"hello world"</span> &lt;&lt; <span class="hljs-number">23</span>;   <span class="hljs-comment">// streaming</span>
s.append(data, size);              <span class="hljs-comment">// append data of specified length</span>
s.flush();                         <span class="hljs-comment">// write data from cache to file</span>
s.close();                         <span class="hljs-comment">// Close the file, it will be called in destructor</span>
</div></code></pre>
<h2 id="21-system-operations-os">21. System operations (os)</h2>
<p>include: <a href="https://github.com/idealvin/co/blob/master/include/co/os.h">co/os.h</a>.</p>
<pre class="hljs"><code><div>os::homedir();  <span class="hljs-comment">// returns the home directory path</span>
os::cwd();      <span class="hljs-comment">// returns the current working directory path</span>
os::exepath();  <span class="hljs-comment">// returns the current process path</span>
os::exename();  <span class="hljs-comment">// returns the current process name</span>
os::pid();      <span class="hljs-comment">// returns the current process id</span>
os::cpunum();   <span class="hljs-comment">// returns the number of CPU cores</span>
os::daemon();   <span class="hljs-comment">// runs as a daemon, only supports Linux platforms</span>
</div></code></pre>
<h2 id="compiling">Compiling</h2>
<p><a href="https://github.com/xmake-io/xmake">Xmake</a> is recommended for compiling the <code>CO</code> project.</p>
<p><a href="https://github.com/izhengfan">izhengfan</a> has helped to provide cmake support. If you need to compile with cmake, please refer to <a href="#compile-with-cmake">here</a>.</p>
<ul>
<li>
<p>Compiler</p>
<ul>
<li>Linux: <a href="https://gcc.gnu.org/projects/cxx-status.html#cxx11">gcc 4.8+</a></li>
<li>Mac: <a href="https://clang.llvm.org/cxx_status.html">clang 3.3+</a></li>
<li>Windows: <a href="https://visualstudio.microsoft.com/">vs2015+</a></li>
</ul>
</li>
<li>
<p>Install xmake</p>
<p>For windows, mac and debian/ubuntu, you can directly go to the <a href="https://github.com/xmake-io/xmake/releases">xmake release page</a> to download the installation package. For other systems, please refer to xmake's <a href="https://xmake.io/#/guide/installation">installation instructions</a>.</p>
<p>Xmake disables compilation as root by default on linux. <a href="https://github.com/waruqi">ruki</a> says it is not safe. You can add the following line to <code>~/.bashrc</code> to enable root compilation:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">export</span> XMAKE_ROOT=y
</div></code></pre>
</li>
<li>
<p>Quick start</p>
<pre class="hljs"><code><div><span class="hljs-comment"># All commands are executed in the root directory of co (the same below)</span>
xmake       <span class="hljs-comment"># build libco and gen by default</span>
xmake -a    <span class="hljs-comment"># build all projects (libco, gen, co/test, co/unitest)</span>
</div></code></pre>
</li>
<li>
<p>Build libco</p>
<pre class="hljs"><code><div>xmake build libco       <span class="hljs-comment"># build libco only</span>
xmake -b libco          <span class="hljs-comment"># the same as above</span>
xmake b libco           <span class="hljs-comment"># the same as above, required newer version of xmake</span>
</div></code></pre>
</li>
<li>
<p>Build and run unitest code</p>
<p><a href="https://github.com/idealvin/co/tree/master/unitest">co/unitest</a> is unit test code that verifies the correctness of the functionality of the base library.</p>
<pre class="hljs"><code><div>xmake build unitest    <span class="hljs-comment"># build can be abbreviated as -b</span>
xmake run unitest -a   <span class="hljs-comment"># run all unit tests</span>
xmake r unitest -a     <span class="hljs-comment"># the same as above</span>
xmake r unitest -os    <span class="hljs-comment"># run unit test os</span>
xmake r unitest -json  <span class="hljs-comment"># run unit test json</span>
</div></code></pre>
</li>
<li>
<p>Build and run test code</p>
<p><a href="https://github.com/idealvin/co/tree/master/test">co/test</a> contains some test code. You can easily add a <code>xxx_test.cc</code> source file in the <code>co/test</code> directory, and then execute <code>xmake build xxx</code> in the co root directory to build it.</p>
<pre class="hljs"><code><div>xmake build flag       <span class="hljs-comment"># compile flag_test.cc</span>
xmake build <span class="hljs-built_in">log</span>        <span class="hljs-comment"># compile log_test.cc</span>
xmake build json       <span class="hljs-comment"># compile json_test.cc</span>
xmake build rapidjson  <span class="hljs-comment"># compile rapidjson_test.cc</span>
xmake build rpc        <span class="hljs-comment"># compile rpc_test.cc</span>

xmake r flag -xz       <span class="hljs-comment"># test flag</span>
xmake r <span class="hljs-built_in">log</span>            <span class="hljs-comment"># test log</span>
xmake r <span class="hljs-built_in">log</span> -cout      <span class="hljs-comment"># also log to terminal</span>
xmake r <span class="hljs-built_in">log</span> -perf      <span class="hljs-comment"># performance test</span>
xmake r json           <span class="hljs-comment"># test json</span>
xmake r rapidjson      <span class="hljs-comment"># test rapidjson</span>
xmake r rpc            <span class="hljs-comment"># start rpc server</span>
xmake r rpc -c         <span class="hljs-comment"># start rpc client</span>
</div></code></pre>
</li>
<li>
<p>Build gen</p>
<pre class="hljs"><code><div>xmake build gen

<span class="hljs-comment"># It is recommended to put gen in the system directory (e.g. /usr/local/bin/).</span>
gen hello_world.proto
</div></code></pre>
<p>Proto file format can refer to <a href="https://github.com/idealvin/co/blob/master/test/__/rpc/hello_world.proto">hello_world.proto</a>.</p>
</li>
<li>
<p>Installation</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Install header files, libco, gen by default.</span>
xmake install -o pkg         <span class="hljs-comment"># package related files to the pkg directory</span>
xmake i -o pkg               <span class="hljs-comment"># the same as above</span>
xmake install -o /usr/<span class="hljs-built_in">local</span>  <span class="hljs-comment"># install to the /usr/local directory</span>
</div></code></pre>
</li>
</ul>
<h3 id="compile-with-cmake">compile with cmake</h3>
<ul>
<li>
<p>Build libco and gen</p>
<p>On the Unix system command line, use <code>cmake/make</code> to build:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> co
mkdir build &amp;&amp; <span class="hljs-built_in">cd</span> build
cmake ..
make -j8
</div></code></pre>
<p>After the building is completed, the <code>libco</code> library file is generated in <code>build/lib</code>, and the <code>gen</code> executable file is generated in <code>build/bin</code>.</p>
</li>
<li>
<p>Build test and unitest</p>
<p>The <code>test</code> and <code>unitest</code> are not built by default. You may use the following options to enable them:</p>
<pre class="hljs"><code><div>cmake .. -DBUILD_TEST=ON -DBUILD_UNITEST=ON
cmake .. -DBUILD_ALL=ON
</div></code></pre>
</li>
<li>
<p>Install co libraries</p>
<p>On the Unix command line, after <code>make</code> is completed, you can install:</p>
<pre class="hljs"><code><div>make install
</div></code></pre>
<p>This command copies the header files, library files, and the gen executable to the appropriate subdirectories under the installation directory. The default installation location under Linux is <code>/usr/local/</code>, so root permission may be required when <code>make install</code>.</p>
<p>To change the installation location, set the <code>CMAKE_INSTALL_PREFIX</code> parameter when cmake:</p>
<pre class="hljs"><code><div>cmake .. -DCMAKE_INSTALL_PREFIX=pkg
</div></code></pre>
</li>
</ul>
<h2 id="donate">Donate</h2>
<font face="Arial" size=3>
<img src="https://github.com/idealvin/docs/raw/master/img/wxzfb.png" alt="" align="center" width="668">
</font>
</body>
</html>
